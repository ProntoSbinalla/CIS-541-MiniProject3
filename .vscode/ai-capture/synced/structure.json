[{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T01:44:24.398Z","tree_hash":"305233b263b2f11c721bc4a114bcab9b5090b7d96c5ad802407123bc7961eefa","added":[{"path":".cursorindexingignore","size":110,"mtime":1764553403640,"ext":""},{"path":"ride_hailing.xlsx","size":49230,"mtime":1764552222428,"ext":"xlsx"},{"path":"Plates/D7CN6Q.png","size":141521,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C2F6VN.png","size":138807,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WV610AS.png","size":251834,"mtime":1757395174000,"ext":"png"},{"path":"Plates/FE0MYMN.png","size":119098,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NCEUQ4.png","size":244976,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DD0BVK.png","size":231367,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M1FNYM.png","size":83630,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NVXWSP.png","size":245427,"mtime":1757395176000,"ext":"png"},{"path":"Plates/H3NFDTN.png","size":245068,"mtime":1757395176000,"ext":"png"},{"path":"Plates/T9GUBH.png","size":232263,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ZPR5EQ.png","size":240261,"mtime":1757395174000,"ext":"png"},{"path":"Plates/Q75Q706.png","size":88704,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JAS3UW.png","size":139414,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EU11YZ5.png","size":86458,"mtime":1757395176000,"ext":"png"},{"path":"Plates/D2FBZ7.png","size":135162,"mtime":1757395174000,"ext":"png"},{"path":"Plates/VS1CZZ6.png","size":184604,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LWPM9VY.png","size":253706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VEWCKJ.png","size":119745,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LPJW7B.png","size":118817,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MH6YC8.png","size":89091,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ULSXU1N.png","size":182443,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B5RMPS.png","size":138505,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CSUAPXD.png","size":186309,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B4BR8T.png","size":119963,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ENV245.png","size":136741,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J2GUWH8.png","size":121270,"mtime":1757395174000,"ext":"png"},{"path":"Plates/RHSDQR.png","size":139565,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NNLXDFC.png","size":238455,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F5SHUBE.png","size":119962,"mtime":1757395174000,"ext":"png"},{"path":"Plates/QEM62SJ.png","size":121752,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F2NJ2W.png","size":118100,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J1ZPXN.png","size":136545,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZJE033.png","size":239133,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CP5Q4M.png","size":89363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/GP93NR.png","size":140661,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XLCPAU8.png","size":252970,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CUQM88J.png","size":249810,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PCNHBH.png","size":231520,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DA7WK8.png","size":243177,"mtime":1757395176000,"ext":"png"},{"path":"Plates/U7R1JP.png","size":175690,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NADRE5G.png","size":120813,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XNC6FCM.png","size":242314,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PFB594.png","size":232538,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KG6EW2.png","size":89461,"mtime":1757395174000,"ext":"png"},{"path":"Plates/V73Q8J2.png","size":143920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VBTXTM.png","size":178067,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JUMX3RJ.png","size":248185,"mtime":1757395174000,"ext":"png"},{"path":"Plates/LLTYXL4.png","size":249205,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C7010N.png","size":85146,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CDBEJB.png","size":174697,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DHSQKAQ.png","size":119529,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FWZU4BU.png","size":139706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/E45LPU.png","size":134295,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WEBGFW1.png","size":86011,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EYELGK.png","size":83642,"mtime":1757395174000,"ext":"png"},{"path":"Plates/MHKVP5.png","size":120192,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PKS29HK.png","size":242629,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NSTQGMR.png","size":184318,"mtime":1757395176000,"ext":"png"},{"path":"Plates/UY767S.png","size":138706,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UUNJPK1.png","size":136920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WASDD1C.png","size":184748,"mtime":1757395174000,"ext":"png"},{"path":"Plates/H5BFXQR.png","size":120260,"mtime":1757395176000,"ext":"png"},{"path":"Plates/A8EFRA5.png","size":138824,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X9A1NUG.png","size":89290,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M2GC6BR.png","size":142782,"mtime":1757395174000,"ext":"png"},{"path":"Plates/K5RM40X.png","size":184771,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KGYDFK.png","size":85354,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PXAVN0E.png","size":184193,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XFCWC9.png","size":180415,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FEEN6D3.png","size":235557,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ALQWNF8.png","size":140989,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BQD3QCC.png","size":139180,"mtime":1757395174000,"ext":"png"},{"path":"Plates/WB28BTE.png","size":88148,"mtime":1757395174000,"ext":"png"},{"path":"Plates/HLTLM1.png","size":130915,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KK5UTE0.png","size":137813,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X7M262S.png","size":143047,"mtime":1757395174000,"ext":"png"},{"path":"Plates/YGYHQM3.png","size":242183,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PJ5RM4.png","size":120211,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BC9EGM.png","size":121179,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UPS7402.png","size":186223,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JXPN4TF.png","size":137857,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C83S708.png","size":251088,"mtime":1757395176000,"ext":"png"},{"path":"Plates/GIX3162.png","size":184369,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KTDPNX4.png","size":87454,"mtime":1757395174000,"ext":"png"},{"path":"Plates/AE2DUT0.png","size":120363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZGYDJ5C.png","size":89532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S3R7YP8.png","size":244654,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S1CWQEC.png","size":89498,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PPX97K.png","size":139610,"mtime":1757395174000,"ext":"png"},{"path":"Plates/BUHUC1.png","size":117532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/B7F5T1Y.png","size":248043,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SQUCQ1.png","size":140293,"mtime":1757395174000,"ext":"png"},{"path":"Plates/R53DE3X.png","size":248527,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XB8PYW.png","size":139192,"mtime":1757395176000,"ext":"png"},{"path":"Plates/YY1PS2.png","size":236611,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JN2DF6.png","size":136942,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DV1K2Z.png","size":177258,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XP82WDL.png","size":243721,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SPQBUSK.png","size":120662,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MGGNAV.png","size":86897,"mtime":1757395174000,"ext":"png"},{"path":"Mini Project 2.twbx","size":6522646,"mtime":1764553199399,"ext":"twbx"},{"path":"map.png","size":110650,"mtime":1764552209823,"ext":"png"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T01:52:19.771Z","tree_hash":"a3628c7f0a831d0b3c4e4039fdd13021385e78d6b586f334fd560e0f4a5e9d97","added":[{"path":"visualize_parking.py","size":2289,"mtime":1764553937187,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Generate scatter plot\nplt.figure(figsize=(10, 8))\nplt.scatter(filtered_df['x'], filtered_df['y'], \n            c=filtered_df['color'], \n            alpha=0.6, \n            s=50)\n\nplt.xlabel('X Coordinate')\nplt.ylabel('Y Coordinate')\nplt.title(f'Parking Status Visualization - {target_datetime}')\nplt.grid(True, alpha=0.3)\n\n# Add legend\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied'),\n                   Patch(facecolor='gray', label='Vacant')]\nplt.legend(handles=legend_elements, loc='upper right')\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T01:52:29.777Z","tree_hash":"b16e5ab8ab7b4872c96172b455d7caa3cf78099dbe76d1d480a9b29970f4088e","added":[],"modified":[{"path":"visualize_parking.py","size":2289,"mtime":1764553946972,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Generate scatter plot\nplt.figure(figsize=(10, 8))\nplt.scatter(filtered_df['x'], filtered_df['y'], \n            c=filtered_df['color'], \n            alpha=0.6, \n            s=50)\n\nplt.xlabel('X Coordinate')\nplt.ylabel('Y Coordinate')\nplt.title(f'Parking Status Visualization - {target_datetime}')\nplt.grid(True, alpha=0.3)\n\n# Add legend\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied'),\n                   Patch(facecolor='gray', label='Vacant')]\nplt.legend(handles=legend_elements, loc='upper right')\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T01:54:09.839Z","tree_hash":"c4d8584e0e109c1737838e36042322067e0f26cc33c3bf0530333cddcfa2f76c","added":[{"path":"parking_visualization.png","size":113547,"mtime":1764554044965,"ext":"png"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T01:59:35.080Z","tree_hash":"7e5af69cce4764e74b54fe0c64aad7fb28fff11b43216e90de841bfc969c0f50","added":[],"modified":[{"path":"visualize_parking.py","size":2311,"mtime":1764554373172,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Generate scatter plot\nplt.figure(figsize=(10, 8))\nplt.scatter(filtered_df['x'], filtered_df['y'], \n            c=filtered_df['color'], \n            alpha=0.6, \n            s=50)\n\nplt.xlabel('X Coordinate')\nplt.ylabel('Y Coordinate')\nplt.title(f'Parking Status Visualization - {target_datetime}')\nplt.grid(True, alpha=0.3)\n\n# Add legend\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied'),\n                   Patch(facecolor='gray', label='Vacant')]\nplt.legend(handles=legend_elements, loc='upper right')\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T01:59:50.095Z","tree_hash":"39fc8130888b4d53471ee424c98fc4211cefe917e0fba86a2ab45b049ba720f7","added":[],"modified":[{"path":"visualize_parking.py","size":3663,"mtime":1764554387460,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Determine the extent based on image dimensions and data range\nx_min, x_max = filtered_df['x'].min(), filtered_df['x'].max()\ny_min, y_max = filtered_df['y'].min(), filtered_df['y'].max()\n\n# Set extent to match image dimensions (assuming image coordinates match data coordinates)\n# You may need to adjust these based on your actual image and data coordinate system\nax.imshow(bg_image, extent=[x_min - (x_max - x_min) * 0.1, x_max + (x_max - x_min) * 0.1,\n                            y_min - (y_max - y_min) * 0.1, y_max + (y_max - y_min) * 0.1],\n          aspect='auto', zorder=0)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:00:05.107Z","tree_hash":"ac8aee422f0b8ced6e74f10fa19b5e64360744b51bebb45f16ac5c94eca8b9af","added":[],"modified":[{"path":"visualize_parking.py","size":3355,"mtime":1764554404420,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Determine the extent based on full data range to ensure map covers all parking spots\nx_min, x_max = df['x'].min(), df['x'].max()\ny_min, y_max = df['y'].min(), df['y'].max()\n\n# Display background image with extent matching the coordinate system\nax.imshow(bg_image, extent=[x_min, x_max, y_min, y_max],\n          aspect='auto', zorder=0)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:00:25.121Z","tree_hash":"73f2783b8b6b38d33698cda6bed659c430366d862750f8a2e2ccf9447fffc1a3","added":[],"modified":[{"path":"visualize_parking.py","size":3355,"mtime":1764554421397,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Determine the extent based on full data range to ensure map covers all parking spots\nx_min, x_max = df['x'].min(), df['x'].max()\ny_min, y_max = df['y'].min(), df['y'].max()\n\n# Display background image with extent matching the coordinate system\nax.imshow(bg_image, extent=[x_min, x_max, y_min, y_max],\n          aspect='auto', zorder=0)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:00:35.128Z","tree_hash":"c76b2a6cde246ca7f1a8808c5f28b826168e48e22574579896c371c77c1a4a6f","added":[],"modified":[{"path":"visualize_parking.py","size":3355,"mtime":1764554432230,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Determine the extent based on full data range to ensure map covers all parking spots\nx_min, x_max = df['x'].min(), df['x'].max()\ny_min, y_max = df['y'].min(), df['y'].max()\n\n# Display background image with extent matching the coordinate system\nax.imshow(bg_image, extent=[x_min, x_max, y_min, y_max],\n          aspect='auto', zorder=0)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:00:40.131Z","tree_hash":"acddd8413a8c0ff0b01307e5dbd291178ade84d0f8c686d4c8d37d988b56b256","added":[],"modified":[{"path":"parking_visualization.png","size":219991,"mtime":1764554438787,"ext":"png"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:03:10.238Z","tree_hash":"babb08b9e38473f7ae5ff5809434d7cac4c5ebca81ed087a9d5e2fa0202adbca","added":[],"modified":[{"path":"visualize_parking.py","size":3358,"mtime":1764554585484,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image using full image dimensions\n# Images have origin at top-left, so we need to flip Y-axis\n# The extent maps image pixels to data coordinates: [left, right, bottom, top]\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='auto', zorder=0, origin='upper')\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:03:30.244Z","tree_hash":"7a12ef924d9e33a0866e0ca91f4efaa8e2e04c77d6b85c45bb1a9119f8390aa6","added":[],"modified":[{"path":"visualize_parking.py","size":3480,"mtime":1764554608875,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image - extent maps image pixels to coordinate system\n# Since images have origin at top-left and matplotlib plots at bottom-left,\n# we need to flip the Y-axis. Extent is [left, right, bottom, top]\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='auto', zorder=0, origin='upper')\n\n# Set axis limits to match the image extent\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:03:50.256Z","tree_hash":"5d6e4fa4751819f4ea69cd86e82465ab333ea5577af20d087990d6bf3e9a9fb1","added":[],"modified":[{"path":"visualize_parking.py","size":3585,"mtime":1764554626894,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Get data coordinate ranges\nx_min, x_max = df['x'].min(), df['x'].max()\ny_min, y_max = df['y'].min(), df['y'].max()\n\n# Display background image\n# Extent maps image pixels [0,width] x [0,height] to data coordinates\n# Use origin='upper' to keep image orientation correct (y=0 at top)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to show the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Flip y-axis to match image coordinates\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:04:15.274Z","tree_hash":"efe2d1d20cce82fb38358d2d5641d49da63ccf69381b6536dfbcd4af128f80cd","added":[],"modified":[{"path":"visualize_parking.py","size":3567,"mtime":1764554654774,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image - map image pixels to coordinate system\n# The image coordinates should match the data coordinates\n# Extent: [left, right, bottom, top] where origin='upper' means top row = top value\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper', interpolation='nearest')\n\n# Set axis limits to show full image\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)\nax.invert_yaxis()  # Invert y-axis so y=0 is at top (like image coordinates)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:04:25.280Z","tree_hash":"185c2bbd53bfc1f00c4f6b282da2bcb5c141ed881835520f1eb721c768c14677","added":[],"modified":[{"path":"visualize_parking.py","size":3519,"mtime":1764554664906,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels directly to coordinate system matching the data\n# extent format: [left, right, bottom, top]\n# With origin='upper': image row 0 (top) maps to y=top, row height-1 maps to y=bottom\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to frame the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:04:45.296Z","tree_hash":"bb625aea66a533257231381f715301e41ad3b0c25e70234f170deef1d5b16f6a","added":[],"modified":[{"path":"visualize_parking.py","size":3639,"mtime":1764554681117,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Remove rows with NaN coordinates (these can't be plotted)\nfiltered_df = filtered_df.dropna(subset=['x', 'y']).copy()\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels directly to coordinate system matching the data\n# extent format: [left, right, bottom, top]\n# With origin='upper': image row 0 (top) maps to y=top, row height-1 maps to y=bottom\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to frame the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:05:05.311Z","tree_hash":"6986655615343acd11e8d2329e7676ece3a7be9aadd7e3fbb5392e070422af29","added":[],"modified":[{"path":"visualize_parking.py","size":3639,"mtime":1764554704321,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Remove rows with NaN coordinates (these can't be plotted)\nfiltered_df = filtered_df.dropna(subset=['x', 'y']).copy()\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels directly to coordinate system matching the data\n# extent format: [left, right, bottom, top]\n# With origin='upper': image row 0 (top) maps to y=top, row height-1 maps to y=bottom\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to frame the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:05:15.316Z","tree_hash":"27bed0d0324cc2c571880e60666dbfe2071a0233f809332e3f25eee262b34f81","added":[],"modified":[{"path":"visualize_parking.py","size":3639,"mtime":1764554712599,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Filter data for the specific timestamp\nfiltered_df = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif filtered_df.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    filtered_df = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Remove rows with NaN coordinates (these can't be plotted)\nfiltered_df = filtered_df.dropna(subset=['x', 'y']).copy()\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nfiltered_df['color'] = filtered_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels directly to coordinate system matching the data\n# extent format: [left, right, bottom, top]\n# With origin='upper': image row 0 (top) maps to y=top, row height-1 maps to y=bottom\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to frame the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(filtered_df['x'], filtered_df['y'], \n           c=filtered_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:05:25.321Z","tree_hash":"721130e5d8c7165cc47e6f0906fbe386ff8a92fe3dcac304fb3efe19d7b90fee","added":[],"modified":[{"path":"parking_visualization.png","size":214368,"mtime":1764554724152,"ext":"png"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:06:15.361Z","tree_hash":"a28234252472798b0e1faa2361eda175c93c23c01c780d3f228903e54fbda7af","added":[],"modified":[{"path":"parking_visualization.png","size":214368,"mtime":1764554773947,"ext":"png"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:08:00.437Z","tree_hash":"43e11efe1c31dd7b22dae89c74ce9292f371c3039e1daeb62b0658dc09ff21da","added":[],"modified":[{"path":"visualize_parking.py","size":4290,"mtime":1764554880229,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels directly to coordinate system matching the data\n# extent format: [left, right, bottom, top]\n# With origin='upper': image row 0 (top) maps to y=top, row height-1 maps to y=bottom\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to frame the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:08:15.450Z","tree_hash":"ef104804b2854d7bb5daa9e563130196fddd3458f4706e4d5b2fe65323d0a8fb","added":[],"modified":[{"path":"visualize_parking.py","size":4407,"mtime":1764554893265,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Get coordinate ranges from the data\nx_min, x_max = plot_df['x'].min(), plot_df['x'].max()\ny_min, y_max = plot_df['y'].min(), plot_df['y'].max()\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to match data coordinate system\n# extent format: [left, right, bottom, top]\n# Use origin='upper' since images have y=0 at top\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to show the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Invert y-axis: y=0 at top (matches image coordinates)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:09:05.488Z","tree_hash":"8d7b8984a506c869cb1e3964a1f26633829e3ddcca42096819ef3a024b1a704b","added":[],"modified":[{"path":"visualize_parking.py","size":4368,"mtime":1764554942233,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map the entire image to coordinate system [0, img_width] x [0, img_height]\n# With origin='upper': image top row (y=0) maps to plot y coordinate specified by top of extent\n# We want image pixel (x, y) to map directly to plot coordinate (x, y)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to show the full image\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Flip y-axis so y=0 is at top (matches image coordinate system)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:09:20.492Z","tree_hash":"979b4a45444b1d86f23963f413986252672c2ab4d617081aad0bd41248d52c50","added":[],"modified":[{"path":"visualize_parking.py","size":4512,"mtime":1764554959394,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels directly to data coordinates\n# extent format: [left, right, bottom, top]\n# With origin='upper', we need to map image row 0 (top) to a high y value\n# Data coordinates: larger y = lower position (matches image where y increases downward)\n# So extent should map image pixel (x, y) to plot coordinate (x, y) directly\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - flip y so larger values are at bottom (matches image coordinates)\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)\nax.invert_yaxis()  # Invert so y increases downward (like image coordinates)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:09:40.508Z","tree_hash":"2b0f69ad1d0e8db115a0b903493d3282adc7d6f840abcc24ac44c490a40cb340","added":[],"modified":[{"path":"visualize_parking.py","size":4513,"mtime":1764554977265,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system matching data coordinates\n# extent format: [left, right, bottom, top]\n# With origin='upper' and extent=[0, width, height, 0]:\n#   - Image row 0 (top) maps to plot y = 0\n#   - Image row height-1 (bottom) maps to plot y = height\n# This makes image pixel (x, y) map to plot coordinate (x, y)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - need to invert y so image orientation matches data\n# Data has larger y values at bottom (like image coordinates)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:09:55.520Z","tree_hash":"c30e395a823cca096975ebe272b13c4e8f01fa202fa0f9e28a2be2f0a4ff6c1a","added":[],"modified":[{"path":"visualize_parking.py","size":4513,"mtime":1764554992474,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system matching data coordinates\n# extent format: [left, right, bottom, top]\n# With origin='upper' and extent=[0, width, height, 0]:\n#   - Image row 0 (top) maps to plot y = 0\n#   - Image row height-1 (bottom) maps to plot y = height\n# This makes image pixel (x, y) map to plot coordinate (x, y)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - need to invert y so image orientation matches data\n# Data has larger y values at bottom (like image coordinates)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:10:00.524Z","tree_hash":"7ce2622cf72f84f9d30d53c2424dc5b42b016bb519b3d02e5d9ca4c7a0fe013c","added":[],"modified":[{"path":"visualize_parking.py","size":4513,"mtime":1764554998084,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system matching data coordinates\n# extent format: [left, right, bottom, top]\n# With origin='upper' and extent=[0, width, height, 0]:\n#   - Image row 0 (top) maps to plot y = 0\n#   - Image row height-1 (bottom) maps to plot y = height\n# This makes image pixel (x, y) map to plot coordinate (x, y)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - need to invert y so image orientation matches data\n# Data has larger y values at bottom (like image coordinates)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:10:05.528Z","tree_hash":"0ce8021147931021e8b556e63d6bd9bcdfde9b99865de0f09560844282ee1147","added":[],"modified":[{"path":"visualize_parking.py","size":4513,"mtime":1764555003705,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system matching data coordinates\n# extent format: [left, right, bottom, top]\n# With origin='upper' and extent=[0, width, height, 0]:\n#   - Image row 0 (top) maps to plot y = 0\n#   - Image row height-1 (bottom) maps to plot y = height\n# This makes image pixel (x, y) map to plot coordinate (x, y)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - need to invert y so image orientation matches data\n# Data has larger y values at bottom (like image coordinates)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:10:10.531Z","tree_hash":"55df3a17d75c379769a1e0f96f7bf85a4c12b0a67f02f261d6264054e5774c78","added":[],"modified":[{"path":"parking_visualization.png","size":237295,"mtime":1764555006188,"ext":"png"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:10:35.554Z","tree_hash":"21448cdd9c9071d76984437128d178342ccaff18d940bd9d567538d2d0199523","added":[{"path":".~Mini Project 2__8702.twbr","size":0,"mtime":1764555034851,"ext":"twbr"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:11:55.618Z","tree_hash":"0d34f6567b140cbaa748430b3b967c021fdb4a229bd2e9f4f9175972e32f34d8","added":[],"modified":[{"path":"visualize_parking.py","size":4556,"mtime":1764555114884,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels directly to plot coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# With origin='upper': image row 0 (top) maps to extent top value\n# We want image pixel (x, y) to directly map to plot coordinate (x, y)\n# So extent=[0, img_width, img_height, 0] maps:\n#   - Image pixel (0, 0) at top-left  plot (0, 0)\n#   - Image pixel (width, height) at bottom-right  plot (width, height)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to show full image\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)\nax.invert_yaxis()  # Invert y-axis so image orientation matches (y=0 at top)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:12:15.632Z","tree_hash":"f3951ae1a6fd40e26cc2e6b3a1af84a6f01b22ce289c84c4df977ce51712184d","added":[],"modified":[{"path":"visualize_parking.py","size":4547,"mtime":1764555133552,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to match data coordinate system\n# extent format: [left, right, bottom, top]\n# With origin='upper': extent=[0, width, height, 0] means:\n#   - Image row 0 (top) maps to plot y = 0 (top of extent)\n#   - Image row height-1 (bottom) maps to plot y = height (bottom of extent)\n# This makes image pixel (x, y) map directly to plot coordinate (x, y)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits and invert y-axis so image coordinates match data coordinates\n# Data has y=0 at top (like image coordinates)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Invert: y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:12:25.635Z","tree_hash":"16ad8e776adbab5dc664842da4557dae7436b2a04c4078b2f09d2405daedb0a7","added":[],"modified":[{"path":"visualize_parking.py","size":4545,"mtime":1764555142086,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Get coordinate ranges from the data\nx_min, x_max = plot_df['x'].min(), plot_df['x'].max()\ny_min, y_max = plot_df['y'].min(), plot_df['y'].max()\nx_range = x_max - x_min\ny_range = y_max - y_min\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map the full image to the coordinate system\n# The data coordinates are pixel positions in the image\n# extent maps image pixels to plot coordinates: [left, right, bottom, top]\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits to match the image coordinate system\n# Invert y-axis so y=0 is at top (matching image coordinates)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: larger y values at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:12:40.644Z","tree_hash":"536c68c2c29c3a41a580d3a1617ecf2379a48a2639f0558cc83fd6b128d5e55d","added":[],"modified":[{"path":"visualize_parking.py","size":4488,"mtime":1764555155691,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Get coordinate ranges from the data\nx_min, x_max = plot_df['x'].min(), plot_df['x'].max()\ny_min, y_max = plot_df['y'].min(), plot_df['y'].max()\nx_range = x_max - x_min\ny_range = y_max - y_min\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system\n# Use origin='upper' since images have (0,0) at top-left\n# extent format: [left, right, bottom, top]\n# We want image pixel (x, y) where y=0 is top to map to plot (x, y)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Invert y-axis: y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:12:45.647Z","tree_hash":"073e37d5a06aa021f746ec4bd259cc8f32b55000ebc867ee4a8bd9b7ab8f9ffe","added":[],"modified":[{"path":"visualize_parking.py","size":4958,"mtime":1764555163919,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Load image to get dimensions for coordinate transformation\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Transform y-coordinates: images have y=0 at top, matplotlib has y=0 at bottom\n# If data coordinates are pixel positions with y increasing downward,\n# we may need to flip them: y_new = img_height - y_old\n# But first, let's try without transformation to see the offset\nplot_df['plot_y'] = img_height - plot_df['y']  # Flip y-coordinate\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Get coordinate ranges from the data\nx_min, x_max = plot_df['x'].min(), plot_df['x'].max()\ny_min, y_max = plot_df['y'].min(), plot_df['y'].max()\nx_range = x_max - x_min\ny_range = y_max - y_min\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system\n# Use origin='upper' since images have (0,0) at top-left\n# extent format: [left, right, bottom, top]\n# We want image pixel (x, y) where y=0 is top to map to plot (x, y)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Invert y-axis: y=0 at top, y=height at bottom\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:12:55.656Z","tree_hash":"a9b6107bdca8370bd787999bab2d6753da3aa28114b1ee765169b63fe675d173","added":[],"modified":[{"path":"visualize_parking.py","size":4661,"mtime":1764555170670,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Load image to get dimensions for coordinate transformation\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Transform y-coordinates: images have y=0 at top, matplotlib has y=0 at bottom\n# If data coordinates are pixel positions with y increasing downward,\n# we may need to flip them: y_new = img_height - y_old\n# But first, let's try without transformation to see the offset\nplot_df['plot_y'] = img_height - plot_df['y']  # Flip y-coordinate\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system matching transformed data coordinates\n# Use origin='upper' since images have (0,0) at top-left\n# extent format: [left, right, bottom, top]\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)  # Standard matplotlib: y=0 at bottom\n\n# Create scatter plot (parking spots appear on top) using transformed coordinates\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:13:05.659Z","tree_hash":"f98f5266c832a880c62886088365ad7c89fee4a1476a398f821f171588dff23c","added":[],"modified":[{"path":"visualize_parking.py","size":4191,"mtime":1764555180715,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to coordinate system matching transformed data coordinates\n# Use origin='upper' since images have (0,0) at top-left\n# extent format: [left, right, bottom, top]\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)  # Standard matplotlib: y=0 at bottom\n\n# Create scatter plot (parking spots appear on top) using transformed coordinates\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:13:15.666Z","tree_hash":"bf2e82321aea69f41d7d9d02cb0391becc52e08c2352286c8904f28720b7114c","added":[],"modified":[{"path":"visualize_parking.py","size":4391,"mtime":1764555194090,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image so pixel (x, y) directly corresponds to plot coordinate (x, y)\n# extent=[0, width, height, 0] with origin='upper' maps:\n#   Image row 0 (top)  plot y = 0 (top of extent)\n#   Image row height-1 (bottom)  plot y = height (bottom of extent)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits and invert y-axis to match image coordinate system\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top (like image coordinates)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:13:30.675Z","tree_hash":"b0104f1bfb1b46779446f1a7977bd0b943d082d4f9b3b10544647006e34de562","added":[],"modified":[{"path":"visualize_parking.py","size":4396,"mtime":1764555207933,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image pixels to match data coordinates\n# Use extent that maps image (0,0) at top-left to plot (0, img_height) at top\n# and image (width, height) at bottom-right to plot (width, 0) at bottom\n# This requires extent=[0, width, 0, height] with origin='upper'\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)  # Standard: y=0 at bottom\nax.invert_yaxis()  # Invert so y=0 is at top, matching image coordinates\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:13:40.684Z","tree_hash":"3926d00f408128fa43867b2b0e00fb4466deaffdfbb143de3a1966a6b9c1163c","added":[],"modified":[{"path":"visualize_parking.py","size":4557,"mtime":1764555218908,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image  \n# Try mapping image pixels directly to data coordinate space\n# The data coordinates (x, y) are pixel positions in the image\n# extent maps image array coordinates to data coordinates: [left, right, bottom, top]\n# With origin='upper', extent=[0, width, height, 0] means:\n#   Image array[0, 0] (top-left pixel)  data coordinate (0, 0)\n#   Image array[height-1, width-1] (bottom-right pixel)  data coordinate (width, height)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y so image coordinate system matches (y increases downward)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:13:45.687Z","tree_hash":"a993a274c4e152f644be942ebd9a32e40a54a3f390d5bdf73b6d774ba9ec278f","added":[],"modified":[{"path":"visualize_parking.py","size":4871,"mtime":1764555224129,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Transform y-coordinates: data has y increasing downward (like image coordinates)\n# but we need to match matplotlib's coordinate system after inverting y-axis\n# Since we'll invert y-axis, we can use coordinates as-is\n# Alternatively, if alignment is still off, try: plot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image  \n# Try mapping image pixels directly to data coordinate space\n# The data coordinates (x, y) are pixel positions in the image\n# extent maps image array coordinates to data coordinates: [left, right, bottom, top]\n# With origin='upper', extent=[0, width, height, 0] means:\n#   Image array[0, 0] (top-left pixel)  data coordinate (0, 0)\n#   Image array[height-1, width-1] (bottom-right pixel)  data coordinate (width, height)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y so image coordinate system matches (y increases downward)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:13:55.696Z","tree_hash":"c6dae5d3154d0f4e71cd56d6beb86efd02bb16f9b8ea7364388af3233ff2426f","added":[],"modified":[{"path":"visualize_parking.py","size":4850,"mtime":1764555234120,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Transform y-coordinates to align with image coordinate system\n# Image has y=0 at top, data coordinates also have larger y at bottom\n# After inverting y-axis, coordinates should align directly\n# If still misaligned, the transformation would be: plot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image  \n# Try mapping image pixels directly to data coordinate space\n# The data coordinates (x, y) are pixel positions in the image\n# extent maps image array coordinates to data coordinates: [left, right, bottom, top]\n# With origin='upper', extent=[0, width, height, 0] means:\n#   Image array[0, 0] (top-left pixel)  data coordinate (0, 0)\n#   Image array[height-1, width-1] (bottom-right pixel)  data coordinate (width, height)\nax.imshow(bg_image, extent=[0, img_width, img_height, 0],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y so image coordinate system matches (y increases downward)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:14:20.713Z","tree_hash":"e70b3d00de3041e7689fca16ad2ea210d20eed7f2ad91dd8c49ce46f54c6dc15","added":[],"modified":[{"path":"visualize_parking.py","size":4667,"mtime":1764555259663,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Transform y-coordinates to align with image coordinate system\n# Image has y=0 at top, data coordinates also have larger y at bottom\n# After inverting y-axis, coordinates should align directly\n# If still misaligned, the transformation would be: plot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# With origin='upper', the image top row maps to the 'top' value in extent\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits and invert y-axis to match image coordinate system (y=0 at top)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top (matching image where y increases downward)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:14:25.718Z","tree_hash":"aef40eca052eddbb75ec57f1c9767b2969eaf64ad46d64fe2bab593cee81d97d","added":[],"modified":[{"path":"visualize_parking.py","size":4667,"mtime":1764555262708,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Transform y-coordinates to align with image coordinate system\n# Image has y=0 at top, data coordinates also have larger y at bottom\n# After inverting y-axis, coordinates should align directly\n# If still misaligned, the transformation would be: plot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# With origin='upper', the image top row maps to the 'top' value in extent\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits and invert y-axis to match image coordinate system (y=0 at top)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top (matching image where y increases downward)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:14:35.725Z","tree_hash":"0deab1897a80424af1245db68cdac6f7fc9d051bce215ee437c86f7c1348b852","added":[],"modified":[{"path":"visualize_parking.py","size":4667,"mtime":1764555275202,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n\n# Transform y-coordinates to align with image coordinate system\n# Image has y=0 at top, data coordinates also have larger y at bottom\n# After inverting y-axis, coordinates should align directly\n# If still misaligned, the transformation would be: plot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# With origin='upper', the image top row maps to the 'top' value in extent\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits and invert y-axis to match image coordinate system (y=0 at top)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top (matching image where y increases downward)\n\n# Create scatter plot (parking spots appear on top)\nax.scatter(plot_df['x'], plot_df['y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:14:40.730Z","tree_hash":"7f90910b97ff9b89d7f0f864cc6683d5758d3b6df942ee8415b1734f0c8adb62","added":[],"modified":[{"path":"parking_visualization.png","size":227660,"mtime":1764555277783,"ext":"png"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:16:50.820Z","tree_hash":"e6a3a7764fc0467b4ae6d376f2345a32c4206ff00569c842cde79a5fc66b89ba","added":[],"modified":[{"path":"visualize_parking.py","size":4835,"mtime":1764555409631,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# With origin='upper', the image top row maps to the 'top' value in extent\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits and invert y-axis to match image coordinate system (y=0 at top)\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top (matching image where y increases downward)\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:17:00.831Z","tree_hash":"6f16e566d35b20d7ca81dc92ad597d62761e60f970b7bf13c1f461f81173e64b","added":[],"modified":[{"path":"visualize_parking.py","size":4779,"mtime":1764555418141,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits (standard matplotlib: y=0 at bottom, y=height at top)\nax.set_xlim(0, img_width)\nax.set_ylim(0, img_height)\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:17:10.838Z","tree_hash":"097a8f2dc748b0e04d507e0164286fb2990ea9a931725af58b8888824662c31c","added":[],"modified":[{"path":"visualize_parking.py","size":4808,"mtime":1764555428385,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:17:15.844Z","tree_hash":"538cdc66b2375aa29d2aaa3f1a517cd84db9308d770c2f8d8289e144137953ee","added":[],"modified":[{"path":"visualize_parking.py","size":4808,"mtime":1764555432678,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:17:25.851Z","tree_hash":"087aaca1010b6d03dfe083c61c8d7c181398a1b04a4420c2df5661137bd68274","added":[],"modified":[{"path":"visualize_parking.py","size":4808,"mtime":1764555444271,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Patch(facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:17:30.852Z","tree_hash":"645af6e80976911411f5d0cc87ad665ec59d61cf51ef87534b94bce6ae68faea","added":[],"modified":[{"path":"parking_visualization.png","size":227229,"mtime":1764555449810,"ext":"png"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:18:30.884Z","tree_hash":"445cc94c5ba647cf26c439ce6b748c420c224a9273d232f44228ca2e35cf0758","added":[],"modified":[{"path":"visualize_parking.py","size":4833,"mtime":1764555507159,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.patches import Circle\nlegend_elements = [Circle((0, 0), 1, facecolor='red', label='Occupied', edgecolor='black', linewidth=0.5),\n                   Circle((0, 0), 1, facecolor='gray', label='Vacant', edgecolor='black', linewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:18:35.892Z","tree_hash":"eb8b5b00a0bc5407cdabdeeec224a35da32d01a5745ee0ffa2d06ac78294789c","added":[],"modified":[{"path":"visualize_parking.py","size":4995,"mtime":1764555513106,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:18:40.894Z","tree_hash":"d225b1191c0d4e5860e08c88366323632170a87a94b74743dfb2623aaff858f3","added":[],"modified":[{"path":"visualize_parking.py","size":4995,"mtime":1764555515961,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:19:40.934Z","tree_hash":"d70c5c710095e1ef569de199d3870fc3e00a6cbff9b645332eaeca3c75238b26","added":[],"modified":[{"path":"visualize_parking.py","size":4995,"mtime":1764555577494,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Create a Test Plot:\n# Generate a Single Static scatter plot for just one specific timestamp from the data\ntarget_timestamp = \"2025-09-17 18:00:00\"\ntarget_datetime = pd.to_datetime(target_timestamp)\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Filter data for the specific timestamp to get status\ntimestamp_data = df[df['current_time'] == target_datetime].copy()\n\n# If no exact match, find the closest timestamp or print available timestamps\nif timestamp_data.empty:\n    print(f\"No data found for timestamp: {target_timestamp}\")\n    print(f\"Available timestamps in the data:\")\n    print(df['current_time'].unique()[:10])  # Show first 10 unique timestamps\n    # Use the first available timestamp instead\n    target_datetime = df['current_time'].iloc[0]\n    timestamp_data = df[df['current_time'] == target_datetime].copy()\n    print(f\"\\nUsing timestamp: {target_datetime}\")\n\n# Calculate status for each slot at this timestamp\ntimestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Merge slot positions with status data (each slot appears once per timestamp)\nslot_status = timestamp_data[['slot_id', 'Status']].drop_duplicates('slot_id', keep='last')\n\n# Combine positions with status - all 24 slots should be shown\nplot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\nplot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n\n# Create color mapping: red for occupied, gray for vacant\ncolor_map = {'occupied': 'red', 'vacant': 'gray'}\nplot_df['color'] = plot_df['Status'].map(color_map)\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\n# Since the image is flipped vertically, we need to flip the y-coordinates accordingly\n# If a point was at y, it should now be at (img_height - y) after flipping\nplot_df['plot_y'] = img_height - plot_df['y']\n\n# Generate scatter plot with larger figure size\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (already flipped vertically)\n# Map image to cover the full image dimensions in pixel coordinates\n# extent format: [left, right, bottom, top] in data coordinates\n# Since image is flipped, use standard matplotlib coordinate system\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Create scatter plot (parking spots appear on top)\n# Use the transformed y-coordinates that match the flipped image\nax.scatter(plot_df['x'], plot_df['plot_y'], \n           c=plot_df['color'], \n           alpha=0.7, \n           s=80,\n           zorder=1,\n           edgecolors='black',\n           linewidths=0.5)\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add title showing date and time\ntitle_text = f'Parking Status Visualization - {target_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")}'\nax.set_title(title_text, fontsize=16, fontweight='bold', pad=20)\n\n# Add legend to explain red and grey dots\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\nplt.tight_layout()\nplt.savefig('parking_visualization.png', dpi=300, bbox_inches='tight', facecolor='white')\nprint(f\"\\nPlot saved as 'parking_visualization.png'\")\nplt.show()\n\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:19:45.940Z","tree_hash":"f6d9f28d21860b5f65d4b4399b44971db76e2aab44b5b68be1456c99ad98b1d8","added":[],"modified":[{"path":"parking_visualization.png","size":230245,"mtime":1764555581485,"ext":"png"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:30:41.413Z","tree_hash":"89f8e96035f9dd55f67e26cd71270552a31d33fea47528571c266abd08788634","added":[],"modified":[{"path":"visualize_parking.py","size":7029,"mtime":1764556237508,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\nscatter_obj = None\nannotation_boxes = []  # Store annotation boxes to remove them each frame\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    global scatter_obj, annotation_boxes\n    \n    # Clear previous annotations\n    for ann in annotation_boxes:\n        ann.remove()\n    annotation_boxes.clear()\n    \n    # Clear previous scatter plot\n    if scatter_obj is not None:\n        scatter_obj.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        scatter_obj = ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                                c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    else:\n        scatter_obj = ax.scatter([], [], c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n                annotation_boxes.append(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Convert figure to image array\n    buf = fig.canvas.buffer_rgba()\n    frame = buf.tobytes()\n    frames.append(buf)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Convert frames to PIL Images and save as GIF\n# Each frame is displayed for 2 seconds (2000 milliseconds)\npil_frames = []\nfor frame in frames:\n    img = Image.fromarray(frame)\n    pil_frames.append(img)\n\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2 seconds per frame in milliseconds\n    loop=0\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:30:51.419Z","tree_hash":"edc3193c08b69fa04586df7973d8e629961dafd951fcc8975ec7053f95ca8c54","added":[],"modified":[{"path":"visualize_parking.py","size":7083,"mtime":1764556247918,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\nscatter_obj = None\nannotation_boxes = []  # Store annotation boxes to remove them each frame\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    global scatter_obj, annotation_boxes\n    \n    # Clear previous annotations\n    for ann in annotation_boxes:\n        ann.remove()\n    annotation_boxes.clear()\n    \n    # Clear previous scatter plot\n    if scatter_obj is not None:\n        scatter_obj.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        scatter_obj = ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                                c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    else:\n        scatter_obj = ax.scatter([], [], c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n                annotation_boxes.append(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Convert figure to numpy array for imageio\n    buf = fig.canvas.buffer_rgba()\n    frame = buf.tobytes()\n    import numpy as np\n    frame_array = np.frombuffer(frame, dtype=np.uint8).reshape(\n        (int(fig.canvas.get_width_height()[1]), int(fig.canvas.get_width_height()[0]), 4)\n    )\n    # Convert RGBA to RGB for GIF\n    frame_rgb = frame_array[:, :, :3]\n    frames.append(frame_rgb)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:30:56.420Z","tree_hash":"e7206c00d2c79d61bffd3945a10f577e43b12efc7f2f892208d3d143597ff9a0","added":[],"modified":[{"path":"visualize_parking.py","size":7102,"mtime":1764556251600,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\nscatter_obj = None\nannotation_boxes = []  # Store annotation boxes to remove them each frame\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    global scatter_obj, annotation_boxes\n    \n    # Clear previous annotations\n    for ann in annotation_boxes:\n        ann.remove()\n    annotation_boxes.clear()\n    \n    # Clear previous scatter plot\n    if scatter_obj is not None:\n        scatter_obj.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        scatter_obj = ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                                c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    else:\n        scatter_obj = ax.scatter([], [], c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n                annotation_boxes.append(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Convert figure to numpy array for imageio\n    buf = fig.canvas.buffer_rgba()\n    frame = buf.tobytes()\n    import numpy as np\n    frame_array = np.frombuffer(frame, dtype=np.uint8).reshape(\n        (int(fig.canvas.get_width_height()[1]), int(fig.canvas.get_width_height()[0]), 4)\n    )\n    # Convert RGBA to RGB for GIF\n    frame_rgb = frame_array[:, :, :3]\n    frames.append(frame_rgb)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:31:01.427Z","tree_hash":"c91929b4f429e1b5126042d84acd40965950e3b3563ef56928a53293524d138e","added":[],"modified":[{"path":"visualize_parking.py","size":7041,"mtime":1764556259368,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\nscatter_obj = None\nannotation_boxes = []  # Store annotation boxes to remove them each frame\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    global scatter_obj, annotation_boxes\n    \n    # Clear previous annotations\n    for ann in annotation_boxes:\n        ann.remove()\n    annotation_boxes.clear()\n    \n    # Clear previous scatter plot\n    if scatter_obj is not None:\n        scatter_obj.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        scatter_obj = ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                                c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    else:\n        scatter_obj = ax.scatter([], [], c='gray', alpha=0.7, s=80, zorder=1,\n                                edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n                annotation_boxes.append(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:31:21.446Z","tree_hash":"bd43c7882b8c45465dec59360a6fad2ce57bab7372e46129e54e36444b5b8ab7","added":[],"modified":[{"path":"visualize_parking.py","size":6640,"mtime":1764556281211,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear all artists except the background image, axes, title, and legend\n    # Remove scatter plots and annotations\n    for artist in ax.collections + list(ax.artists):\n        artist.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:31:31.439Z","tree_hash":"9b10db0b355a9f549f42baa8549430e04c25c05c7de138778c6c1e8b2b3b7060","added":[],"modified":[{"path":"visualize_parking.py","size":6899,"mtime":1764556288153,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections) and annotation artists\n    # But preserve the background image, title, legend, and spines\n    collections_to_remove = list(ax.collections)\n    for coll in collections_to_remove:\n        coll.remove()\n    \n    # Remove annotation artists (but keep the title text which is in ax.texts)\n    artists_to_remove = [art for art in ax.artists if art != title_text_obj]\n    for art in artists_to_remove:\n        art.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:31:36.439Z","tree_hash":"2e1521d3aca602feba6144c8ae096df12b407221fb78e1789617b039e3bafd57","added":[],"modified":[{"path":"visualize_parking.py","size":6912,"mtime":1764556295298,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections) and annotation artists\n    # But preserve the background image, title, legend, and spines\n    collections_to_remove = list(ax.collections)\n    for coll in collections_to_remove:\n        coll.remove()\n    \n    # Remove annotation artists (but keep the title text which is in ax.texts)\n    artists_to_remove = [art for art in ax.artists if art != title_text_obj]\n    for art in artists_to_remove:\n        art.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:31:41.445Z","tree_hash":"0a2c741526d17a7a0873076815aabd05b1bc1b6ec3814053f07f16cad5db8c76","added":[],"modified":[{"path":"visualize_parking.py","size":6929,"mtime":1764556298135,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    collections_to_remove = list(ax.collections)\n    for coll in collections_to_remove:\n        coll.remove()\n    \n    # Remove annotation artists (but preserve title text and legend)\n    # AnnotationBbox objects are added as artists\n    artists_to_remove = [art for art in ax.artists \n                        if art != title_text_obj and not isinstance(art, type(legend_obj))]\n    for art in artists_to_remove:\n        art.remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:31:56.453Z","tree_hash":"76dacc24dfdbf840670320e978906ed4bb3e7452151ab7e68036962b815e7316","added":[],"modified":[{"path":"visualize_parking.py","size":6824,"mtime":1764556312853,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects)\n    while ax.artists:\n        art = ax.artists[0]\n        # Skip title text which is not an annotation artist\n        if art != title_text_obj:\n            art.remove()\n        else:\n            break\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:32:01.459Z","tree_hash":"767fbe2b284df865e7bbddefbb5852d049ef88c785173ca3658aa4dc3a7bf03b","added":[],"modified":[{"path":"visualize_parking.py","size":6775,"mtime":1764556317840,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:32:11.456Z","tree_hash":"69bd07478711357ee3d89f36d089f9e701e74485ad83d76869d0ba14c7238366","added":[],"modified":[{"path":"visualize_parking.py","size":6775,"mtime":1764556330412,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:32:26.457Z","tree_hash":"7e41892a91b799157e941b6d79be0c7e063236c5485742b495869fd3ae463427","added":[],"modified":[{"path":"visualize_parking.py","size":6775,"mtime":1764556342611,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:32:31.459Z","tree_hash":"83ff07bc3e7260b17c859268d219c6e86d5be32ea24582c56a4e31dfd1ece089","added":[],"modified":[{"path":"visualize_parking.py","size":6775,"mtime":1764556347376,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:33:06.481Z","tree_hash":"0ab7bb52369bb96ea76605fdfe6f3b7cc29b6563b87fbe6c500f441422a33424","added":[],"modified":[{"path":"visualize_parking.py","size":6776,"mtime":1764556384094,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_argb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:33:11.491Z","tree_hash":"0e2e18a8c2c308d61e67ed49b8b98833c990721ba0954a8b937f410dd991ff61","added":[],"modified":[{"path":"visualize_parking.py","size":6776,"mtime":1764556391333,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_argb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:34:06.516Z","tree_hash":"2cbdbf630234bf825a29b7aa052eebdc1dbbcd2b542bf1d205ec8e55ea4f8e52","added":[],"modified":[{"path":"visualize_parking.py","size":6799,"mtime":1764556446055,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw_idle()\n    fig.canvas.flush_events()\n    \n    # Convert figure to numpy array for imageio\n    # Get the dimensions\n    width, height = fig.canvas.get_width_height()\n    \n    # Get the buffer\n    buf = np.frombuffer(fig.canvas.tostring_argb(), dtype=np.uint8)\n    frame_array = buf.reshape((height, width, 3))\n    frames.append(frame_array)\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:34:16.525Z","tree_hash":"999d3195447203453978ffba76b0141806bdd5628bce511b03d9ee4e07f15166","added":[],"modified":[{"path":"visualize_parking.py","size":6988,"mtime":1764556453769,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:34:26.529Z","tree_hash":"a83350757ed4d2b44f136d13cd1d1ba393edeee588d1e8c46018443629cfa3be","added":[],"modified":[{"path":"visualize_parking.py","size":6988,"mtime":1764556466416,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:34:31.533Z","tree_hash":"9eba5727ec49a84982c41459cdd0e4b36840e88630e75a9b85b0d2d53e8427fa","added":[],"modified":[{"path":"visualize_parking.py","size":6988,"mtime":1764556469282,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (2000 milliseconds)\nimageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:34:46.545Z","tree_hash":"0ea8e29bd3d55baac90c48d8de347b68fce9ae7590c42e781b370c0842af3776","added":[{"path":"parking_animation.gif","size":2637326,"mtime":1764556484652,"ext":"gif"}],"modified":[{"path":"parking_animation.gif","size":2637326,"mtime":1764556484652,"ext":"gif"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:35:51.583Z","tree_hash":"8564dc3c579829b99326a238ff3ebc507813934c5a05b498fbc7eb3c732a5016","added":[],"modified":[{"path":"visualize_parking.py","size":7196,"mtime":1764556551201,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (duration parameter is in seconds)\n# Create duration list to ensure each frame gets exactly 2 seconds\nframe_duration = 2.0  # 2 seconds per frame\ndurations = [frame_duration] * len(frames)  # Same duration for all frames\n\nimageio.mimsave('parking_animation.gif', frames, duration=durations, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:36:06.592Z","tree_hash":"75c2e0e42c8e9475472646dd5efb1c577eb207c3ccf671051be8194758edec2c","added":[],"modified":[{"path":"visualize_parking.py","size":7196,"mtime":1764556564674,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (duration parameter is in seconds)\n# Create duration list to ensure each frame gets exactly 2 seconds\nframe_duration = 2.0  # 2 seconds per frame\ndurations = [frame_duration] * len(frames)  # Same duration for all frames\n\nimageio.mimsave('parking_animation.gif', frames, duration=durations, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:36:21.602Z","tree_hash":"1cf12f4bc8fd3fe5d3f301d7ab8f16a789a76099ee3c0df50c7d67a48ae18a38","added":[],"modified":[{"path":"parking_animation.gif","size":2637326,"mtime":1764556580740,"ext":"gif"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:37:01.637Z","tree_hash":"c4f7891336f4623db1a3c84dd382ab724411333fd58af0aa5374da74cc8d98be","added":[],"modified":[{"path":"visualize_parking.py","size":7196,"mtime":1764556619136,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (duration parameter is in seconds)\n# Create duration list to ensure each frame gets exactly 2 seconds\nframe_duration = 2.0  # 2 seconds per frame\ndurations = [frame_duration] * len(frames)  # Same duration for all frames\n\nimageio.mimsave('parking_animation.gif', frames, duration=durations, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:37:06.642Z","tree_hash":"80b3621bc6a08f7c39c7253988a32fb7c3c739c829e61a7bc65681982a5de97c","added":[],"modified":[{"path":"visualize_parking.py","size":7196,"mtime":1764556624028,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nprint(f\"  Total frames: {len(frames)}\")\nprint(f\"  Duration per frame: 2 seconds\")\n\n# Save as GIF using imageio\n# Each frame is displayed for 2 seconds (duration parameter is in seconds)\n# Create duration list to ensure each frame gets exactly 2 seconds\nframe_duration = 2.0  # 2 seconds per frame\ndurations = [frame_duration] * len(frames)  # Same duration for all frames\n\nimageio.mimsave('parking_animation.gif', frames, duration=durations, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:37:31.662Z","tree_hash":"129d09fd4233a167a35436e3aeed683ad0342e84ae3a8e615ea39590cbefe02f","added":[],"modified":[{"path":".~Mini Project 2__8702.twbr","size":9091727,"mtime":1764556651053,"ext":"twbr"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:39:01.733Z","tree_hash":"24920947c891760c2ae33ec454ef42ce83027103d92c9a04f1c5a38e1bd7b0a2","added":[],"modified":[{"path":"visualize_parking.py","size":7687,"mtime":1764556739266,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Duplicate each frame multiple times to ensure it displays for 2 seconds\n# At 10 frames per second, we need 20 duplicate frames per minute to get 2 seconds\nframes_per_minute = 20  # Number of times to repeat each frame\nduplicated_frames = []\nfor frame in frames:\n    for _ in range(frames_per_minute):\n        duplicated_frames.append(frame.copy())\n\nprint(f\"  Original frames: {len(frames)}\")\nprint(f\"  Total frames after duplication: {len(duplicated_frames)}\")\nprint(f\"  Duration per minute: 2 seconds\")\n\n# Save as GIF using imageio\n# Each duplicated frame displays for 0.1 seconds (100ms)\n# So each original frame (duplicated 20 times) displays for 2 seconds total\nframe_duration = 0.1  # 0.1 seconds per duplicated frame (10 fps)\ndurations = [frame_duration] * len(duplicated_frames)\n\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\nimageio.mimsave('parking_animation.gif', duplicated_frames, duration=durations, loop=0)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:39:21.748Z","tree_hash":"9a132508502749661154fdf6dd170d6a9c735eb993bbde589d129bdfdc148092","added":[],"modified":[{"path":"visualize_parking.py","size":7770,"mtime":1764556757563,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert frames to PIL Images for better GIF control\npil_frames = []\nfor frame_array in frames:\n    # Convert numpy array to PIL Image\n    if frame_array.shape[2] == 4:\n        # RGBA\n        img = Image.fromarray(frame_array, 'RGBA')\n        # Create white background and paste\n        background = Image.new('RGB', img.size, (255, 255, 255))\n        background.paste(img, mask=img.split()[3] if img.mode == 'RGBA' else None)\n        pil_frames.append(background)\n    else:\n        # RGB\n        pil_frames.append(Image.fromarray(frame_array, 'RGB'))\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:39:41.761Z","tree_hash":"25c52d809d510a372821db2830ce420a4abeb78a9571602f638c1e5d89d07739","added":[],"modified":[{"path":"visualize_parking.py","size":7413,"mtime":1764556777820,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:39:46.766Z","tree_hash":"251e34939ad544a4e627e8b6868cf16ddbe1b241b08e511c9870ff2a2288517d","added":[],"modified":[{"path":"visualize_parking.py","size":7413,"mtime":1764556785133,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:40:16.790Z","tree_hash":"4b8772fa2326fac8aaf254450e7c996a6bdf6300de452e9d11369a4a3efdcc16","added":[],"modified":[{"path":"visualize_parking.py","size":7413,"mtime":1764556814498,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:40:21.795Z","tree_hash":"e2eeff63d7da34bd54fcff3bb10b5ce4b5f0ddf576b1a6d4f71b676ac457b1fc","added":[],"modified":[{"path":"visualize_parking.py","size":7413,"mtime":1764556817409,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Occupied', \n                          markerfacecolor='red', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n                   Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='gray', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:40:36.807Z","tree_hash":"e1c6c318ec9360bb798d6ae6e88c8cb6ee91d00c66b8cbf45bc96c947d7b0f88","added":[],"modified":[{"path":"parking_animation.gif","size":2637614,"mtime":1764556834347,"ext":"gif"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:41:46.846Z","tree_hash":"f6f10da47c947a06ab7f4197f0555c9b68a0ef2930cfb59734c171eabe7c7bd8","added":[],"modified":[{"path":"visualize_parking.py","size":7225,"mtime":1764556902746,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as gray dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='gray', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:41:51.856Z","tree_hash":"881dc1c60780161d6c8ff93683fa677776711f150bdf7ff0cad4a633da2838bf","added":[],"modified":[{"path":"visualize_parking.py","size":7227,"mtime":1764556910068,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:42:01.857Z","tree_hash":"c1aa54c38b3bb1d3a73eb57bbcfa4ef7ca40a8a1c514e04522e011aae7b22620","added":[],"modified":[{"path":"visualize_parking.py","size":7227,"mtime":1764556918183,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:42:06.862Z","tree_hash":"0b5ea9afb642af6ada8962f9c2a074a289c0b6341112749a9b1f39f129a3d91b","added":[],"modified":[{"path":"visualize_parking.py","size":7227,"mtime":1764556922562,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:42:11.864Z","tree_hash":"fbeb6694d504f71a1846257142591974de992635f43eb6d32274f88f5e0e934e","added":[],"modified":[{"path":"visualize_parking.py","size":7227,"mtime":1764556929183,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:42:21.869Z","tree_hash":"1d649153a26ca74ff0b9821f9697e9959067fe7c82122928e512248dedb520e0","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1764556941462,"ext":"gif"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:42:26.875Z","tree_hash":"51dc46b9d23db23f1184f972e85d0b60cc7cd4890944d391eaed5367b3c0708b","added":[],"modified":[{"path":"parking_animation.gif","size":2976487,"mtime":1764556944134,"ext":"gif"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:42:31.880Z","tree_hash":"f604dc8879b279baf293f8bc2aaa60f9c0441eaa353956f68fed759b7efc65b1","added":[],"modified":[{"path":"visualize_parking.py","size":7227,"mtime":1764556950729,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:43:06.902Z","tree_hash":"7a9676b39a696954c84d403ae2b7ff4dd79804ca2046476dcaf33fd1c6347dd7","added":[],"modified":[{"path":"visualize_parking.py","size":7227,"mtime":1764556985701,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-01T02:47:42.083Z","tree_hash":"46cdf7f4f7a79ac5edd13a223aadaf665fad2335856681fb266780b2d81dab06","added":[{"path":"MiniProject2_Meshach Samuel.docx","size":8068,"mtime":1764557243257,"ext":"docx"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-08T00:07:04.544Z","tree_hash":"474ab35bde1852820447290015f53456b1b3b90b12572bf5590f5661ba506065","added":[{"path":".cursorindexingignore","size":110,"mtime":1764553403640,"ext":""},{"path":"ride_hailing.xlsx","size":49230,"mtime":1764552222428,"ext":"xlsx"},{"path":"Plates/D7CN6Q.png","size":141521,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C2F6VN.png","size":138807,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WV610AS.png","size":251834,"mtime":1757395174000,"ext":"png"},{"path":"Plates/FE0MYMN.png","size":119098,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NCEUQ4.png","size":244976,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DD0BVK.png","size":231367,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M1FNYM.png","size":83630,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NVXWSP.png","size":245427,"mtime":1757395176000,"ext":"png"},{"path":"Plates/H3NFDTN.png","size":245068,"mtime":1757395176000,"ext":"png"},{"path":"Plates/T9GUBH.png","size":232263,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ZPR5EQ.png","size":240261,"mtime":1757395174000,"ext":"png"},{"path":"Plates/Q75Q706.png","size":88704,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JAS3UW.png","size":139414,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EU11YZ5.png","size":86458,"mtime":1757395176000,"ext":"png"},{"path":"Plates/D2FBZ7.png","size":135162,"mtime":1757395174000,"ext":"png"},{"path":"Plates/VS1CZZ6.png","size":184604,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LWPM9VY.png","size":253706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VEWCKJ.png","size":119745,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LPJW7B.png","size":118817,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MH6YC8.png","size":89091,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ULSXU1N.png","size":182443,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B5RMPS.png","size":138505,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CSUAPXD.png","size":186309,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B4BR8T.png","size":119963,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ENV245.png","size":136741,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J2GUWH8.png","size":121270,"mtime":1757395174000,"ext":"png"},{"path":"Plates/RHSDQR.png","size":139565,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NNLXDFC.png","size":238455,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F5SHUBE.png","size":119962,"mtime":1757395174000,"ext":"png"},{"path":"Plates/QEM62SJ.png","size":121752,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F2NJ2W.png","size":118100,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J1ZPXN.png","size":136545,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZJE033.png","size":239133,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CP5Q4M.png","size":89363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/GP93NR.png","size":140661,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XLCPAU8.png","size":252970,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CUQM88J.png","size":249810,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PCNHBH.png","size":231520,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DA7WK8.png","size":243177,"mtime":1757395176000,"ext":"png"},{"path":"Plates/U7R1JP.png","size":175690,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NADRE5G.png","size":120813,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XNC6FCM.png","size":242314,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PFB594.png","size":232538,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KG6EW2.png","size":89461,"mtime":1757395174000,"ext":"png"},{"path":"Plates/V73Q8J2.png","size":143920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VBTXTM.png","size":178067,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JUMX3RJ.png","size":248185,"mtime":1757395174000,"ext":"png"},{"path":"Plates/LLTYXL4.png","size":249205,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C7010N.png","size":85146,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CDBEJB.png","size":174697,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DHSQKAQ.png","size":119529,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FWZU4BU.png","size":139706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/E45LPU.png","size":134295,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WEBGFW1.png","size":86011,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EYELGK.png","size":83642,"mtime":1757395174000,"ext":"png"},{"path":"Plates/MHKVP5.png","size":120192,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PKS29HK.png","size":242629,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NSTQGMR.png","size":184318,"mtime":1757395176000,"ext":"png"},{"path":"Plates/UY767S.png","size":138706,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UUNJPK1.png","size":136920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WASDD1C.png","size":184748,"mtime":1757395174000,"ext":"png"},{"path":"Plates/H5BFXQR.png","size":120260,"mtime":1757395176000,"ext":"png"},{"path":"Plates/A8EFRA5.png","size":138824,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X9A1NUG.png","size":89290,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M2GC6BR.png","size":142782,"mtime":1757395174000,"ext":"png"},{"path":"Plates/K5RM40X.png","size":184771,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KGYDFK.png","size":85354,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PXAVN0E.png","size":184193,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XFCWC9.png","size":180415,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FEEN6D3.png","size":235557,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ALQWNF8.png","size":140989,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BQD3QCC.png","size":139180,"mtime":1757395174000,"ext":"png"},{"path":"Plates/WB28BTE.png","size":88148,"mtime":1757395174000,"ext":"png"},{"path":"Plates/HLTLM1.png","size":130915,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KK5UTE0.png","size":137813,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X7M262S.png","size":143047,"mtime":1757395174000,"ext":"png"},{"path":"Plates/YGYHQM3.png","size":242183,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PJ5RM4.png","size":120211,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BC9EGM.png","size":121179,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UPS7402.png","size":186223,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JXPN4TF.png","size":137857,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C83S708.png","size":251088,"mtime":1757395176000,"ext":"png"},{"path":"Plates/GIX3162.png","size":184369,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KTDPNX4.png","size":87454,"mtime":1757395174000,"ext":"png"},{"path":"Plates/AE2DUT0.png","size":120363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZGYDJ5C.png","size":89532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S3R7YP8.png","size":244654,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S1CWQEC.png","size":89498,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PPX97K.png","size":139610,"mtime":1757395174000,"ext":"png"},{"path":"Plates/BUHUC1.png","size":117532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/B7F5T1Y.png","size":248043,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SQUCQ1.png","size":140293,"mtime":1757395174000,"ext":"png"},{"path":"Plates/R53DE3X.png","size":248527,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XB8PYW.png","size":139192,"mtime":1757395176000,"ext":"png"},{"path":"Plates/YY1PS2.png","size":236611,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JN2DF6.png","size":136942,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DV1K2Z.png","size":177258,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XP82WDL.png","size":243721,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SPQBUSK.png","size":120662,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MGGNAV.png","size":86897,"mtime":1757395174000,"ext":"png"},{"path":"MiniProject2_Meshach Samuel.docx","size":8068,"mtime":1764557243257,"ext":"docx"},{"path":"Mini Project 2.twbx","size":6509886,"mtime":1764598219199,"ext":"twbx"},{"path":"visualize_parking.py","size":7227,"mtime":1764556985701,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"},{"path":"map.png","size":110650,"mtime":1764552209823,"ext":"png"},{"path":"parking_visualization.png","size":230245,"mtime":1764555581485,"ext":"png"},{"path":"parking_animation.gif","size":2976487,"mtime":1764556944134,"ext":"gif"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-08T00:15:53.020Z","tree_hash":"474ab35bde1852820447290015f53456b1b3b90b12572bf5590f5661ba506065","added":[{"path":".cursorindexingignore","size":110,"mtime":1764553403640,"ext":""},{"path":"ride_hailing.xlsx","size":49230,"mtime":1764552222428,"ext":"xlsx"},{"path":"visualize_parking.py","size":7227,"mtime":1764556985701,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"},{"path":"map.png","size":110650,"mtime":1764552209823,"ext":"png"},{"path":"parking_visualization.png","size":230245,"mtime":1764555581485,"ext":"png"},{"path":"parking_animation.gif","size":2976487,"mtime":1764556944134,"ext":"gif"},{"path":"MiniProject2_Meshach Samuel.docx","size":8068,"mtime":1764557243257,"ext":"docx"},{"path":"Mini Project 2.twbx","size":6509886,"mtime":1764598219199,"ext":"twbx"},{"path":"Plates/D7CN6Q.png","size":141521,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C2F6VN.png","size":138807,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WV610AS.png","size":251834,"mtime":1757395174000,"ext":"png"},{"path":"Plates/FE0MYMN.png","size":119098,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NCEUQ4.png","size":244976,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DD0BVK.png","size":231367,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M1FNYM.png","size":83630,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NVXWSP.png","size":245427,"mtime":1757395176000,"ext":"png"},{"path":"Plates/H3NFDTN.png","size":245068,"mtime":1757395176000,"ext":"png"},{"path":"Plates/T9GUBH.png","size":232263,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ZPR5EQ.png","size":240261,"mtime":1757395174000,"ext":"png"},{"path":"Plates/Q75Q706.png","size":88704,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JAS3UW.png","size":139414,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EU11YZ5.png","size":86458,"mtime":1757395176000,"ext":"png"},{"path":"Plates/D2FBZ7.png","size":135162,"mtime":1757395174000,"ext":"png"},{"path":"Plates/VS1CZZ6.png","size":184604,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LWPM9VY.png","size":253706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VEWCKJ.png","size":119745,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LPJW7B.png","size":118817,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MH6YC8.png","size":89091,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ULSXU1N.png","size":182443,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B5RMPS.png","size":138505,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CSUAPXD.png","size":186309,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B4BR8T.png","size":119963,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ENV245.png","size":136741,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J2GUWH8.png","size":121270,"mtime":1757395174000,"ext":"png"},{"path":"Plates/RHSDQR.png","size":139565,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NNLXDFC.png","size":238455,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F5SHUBE.png","size":119962,"mtime":1757395174000,"ext":"png"},{"path":"Plates/QEM62SJ.png","size":121752,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F2NJ2W.png","size":118100,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J1ZPXN.png","size":136545,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZJE033.png","size":239133,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CP5Q4M.png","size":89363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/GP93NR.png","size":140661,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XLCPAU8.png","size":252970,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CUQM88J.png","size":249810,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PCNHBH.png","size":231520,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DA7WK8.png","size":243177,"mtime":1757395176000,"ext":"png"},{"path":"Plates/U7R1JP.png","size":175690,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NADRE5G.png","size":120813,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XNC6FCM.png","size":242314,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PFB594.png","size":232538,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KG6EW2.png","size":89461,"mtime":1757395174000,"ext":"png"},{"path":"Plates/V73Q8J2.png","size":143920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VBTXTM.png","size":178067,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JUMX3RJ.png","size":248185,"mtime":1757395174000,"ext":"png"},{"path":"Plates/LLTYXL4.png","size":249205,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C7010N.png","size":85146,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CDBEJB.png","size":174697,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DHSQKAQ.png","size":119529,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FWZU4BU.png","size":139706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/E45LPU.png","size":134295,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WEBGFW1.png","size":86011,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EYELGK.png","size":83642,"mtime":1757395174000,"ext":"png"},{"path":"Plates/MHKVP5.png","size":120192,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PKS29HK.png","size":242629,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NSTQGMR.png","size":184318,"mtime":1757395176000,"ext":"png"},{"path":"Plates/UY767S.png","size":138706,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UUNJPK1.png","size":136920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WASDD1C.png","size":184748,"mtime":1757395174000,"ext":"png"},{"path":"Plates/H5BFXQR.png","size":120260,"mtime":1757395176000,"ext":"png"},{"path":"Plates/A8EFRA5.png","size":138824,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X9A1NUG.png","size":89290,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M2GC6BR.png","size":142782,"mtime":1757395174000,"ext":"png"},{"path":"Plates/K5RM40X.png","size":184771,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KGYDFK.png","size":85354,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PXAVN0E.png","size":184193,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XFCWC9.png","size":180415,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FEEN6D3.png","size":235557,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ALQWNF8.png","size":140989,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BQD3QCC.png","size":139180,"mtime":1757395174000,"ext":"png"},{"path":"Plates/WB28BTE.png","size":88148,"mtime":1757395174000,"ext":"png"},{"path":"Plates/HLTLM1.png","size":130915,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KK5UTE0.png","size":137813,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X7M262S.png","size":143047,"mtime":1757395174000,"ext":"png"},{"path":"Plates/YGYHQM3.png","size":242183,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PJ5RM4.png","size":120211,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BC9EGM.png","size":121179,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UPS7402.png","size":186223,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JXPN4TF.png","size":137857,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C83S708.png","size":251088,"mtime":1757395176000,"ext":"png"},{"path":"Plates/GIX3162.png","size":184369,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KTDPNX4.png","size":87454,"mtime":1757395174000,"ext":"png"},{"path":"Plates/AE2DUT0.png","size":120363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZGYDJ5C.png","size":89532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S3R7YP8.png","size":244654,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S1CWQEC.png","size":89498,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PPX97K.png","size":139610,"mtime":1757395174000,"ext":"png"},{"path":"Plates/BUHUC1.png","size":117532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/B7F5T1Y.png","size":248043,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SQUCQ1.png","size":140293,"mtime":1757395174000,"ext":"png"},{"path":"Plates/R53DE3X.png","size":248527,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XB8PYW.png","size":139192,"mtime":1757395176000,"ext":"png"},{"path":"Plates/YY1PS2.png","size":236611,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JN2DF6.png","size":136942,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DV1K2Z.png","size":177258,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XP82WDL.png","size":243721,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SPQBUSK.png","size":120662,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MGGNAV.png","size":86897,"mtime":1757395174000,"ext":"png"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:28:32.846Z","tree_hash":"474ab35bde1852820447290015f53456b1b3b90b12572bf5590f5661ba506065","added":[{"path":".cursorindexingignore","size":110,"mtime":1764553403640,"ext":""},{"path":"ride_hailing.xlsx","size":49230,"mtime":1764552222428,"ext":"xlsx"},{"path":"Plates/D7CN6Q.png","size":141521,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C2F6VN.png","size":138807,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WV610AS.png","size":251834,"mtime":1757395174000,"ext":"png"},{"path":"Plates/FE0MYMN.png","size":119098,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NCEUQ4.png","size":244976,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DD0BVK.png","size":231367,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M1FNYM.png","size":83630,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NVXWSP.png","size":245427,"mtime":1757395176000,"ext":"png"},{"path":"Plates/H3NFDTN.png","size":245068,"mtime":1757395176000,"ext":"png"},{"path":"Plates/T9GUBH.png","size":232263,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ZPR5EQ.png","size":240261,"mtime":1757395174000,"ext":"png"},{"path":"Plates/Q75Q706.png","size":88704,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JAS3UW.png","size":139414,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EU11YZ5.png","size":86458,"mtime":1757395176000,"ext":"png"},{"path":"Plates/D2FBZ7.png","size":135162,"mtime":1757395174000,"ext":"png"},{"path":"Plates/VS1CZZ6.png","size":184604,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LWPM9VY.png","size":253706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VEWCKJ.png","size":119745,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LPJW7B.png","size":118817,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MH6YC8.png","size":89091,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ULSXU1N.png","size":182443,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B5RMPS.png","size":138505,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CSUAPXD.png","size":186309,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B4BR8T.png","size":119963,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ENV245.png","size":136741,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J2GUWH8.png","size":121270,"mtime":1757395174000,"ext":"png"},{"path":"Plates/RHSDQR.png","size":139565,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NNLXDFC.png","size":238455,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F5SHUBE.png","size":119962,"mtime":1757395174000,"ext":"png"},{"path":"Plates/QEM62SJ.png","size":121752,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F2NJ2W.png","size":118100,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J1ZPXN.png","size":136545,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZJE033.png","size":239133,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CP5Q4M.png","size":89363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/GP93NR.png","size":140661,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XLCPAU8.png","size":252970,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CUQM88J.png","size":249810,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PCNHBH.png","size":231520,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DA7WK8.png","size":243177,"mtime":1757395176000,"ext":"png"},{"path":"Plates/U7R1JP.png","size":175690,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NADRE5G.png","size":120813,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XNC6FCM.png","size":242314,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PFB594.png","size":232538,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KG6EW2.png","size":89461,"mtime":1757395174000,"ext":"png"},{"path":"Plates/V73Q8J2.png","size":143920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VBTXTM.png","size":178067,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JUMX3RJ.png","size":248185,"mtime":1757395174000,"ext":"png"},{"path":"Plates/LLTYXL4.png","size":249205,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C7010N.png","size":85146,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CDBEJB.png","size":174697,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DHSQKAQ.png","size":119529,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FWZU4BU.png","size":139706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/E45LPU.png","size":134295,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WEBGFW1.png","size":86011,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EYELGK.png","size":83642,"mtime":1757395174000,"ext":"png"},{"path":"Plates/MHKVP5.png","size":120192,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PKS29HK.png","size":242629,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NSTQGMR.png","size":184318,"mtime":1757395176000,"ext":"png"},{"path":"Plates/UY767S.png","size":138706,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UUNJPK1.png","size":136920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WASDD1C.png","size":184748,"mtime":1757395174000,"ext":"png"},{"path":"Plates/H5BFXQR.png","size":120260,"mtime":1757395176000,"ext":"png"},{"path":"Plates/A8EFRA5.png","size":138824,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X9A1NUG.png","size":89290,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M2GC6BR.png","size":142782,"mtime":1757395174000,"ext":"png"},{"path":"Plates/K5RM40X.png","size":184771,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KGYDFK.png","size":85354,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PXAVN0E.png","size":184193,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XFCWC9.png","size":180415,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FEEN6D3.png","size":235557,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ALQWNF8.png","size":140989,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BQD3QCC.png","size":139180,"mtime":1757395174000,"ext":"png"},{"path":"Plates/WB28BTE.png","size":88148,"mtime":1757395174000,"ext":"png"},{"path":"Plates/HLTLM1.png","size":130915,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KK5UTE0.png","size":137813,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X7M262S.png","size":143047,"mtime":1757395174000,"ext":"png"},{"path":"Plates/YGYHQM3.png","size":242183,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PJ5RM4.png","size":120211,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BC9EGM.png","size":121179,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UPS7402.png","size":186223,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JXPN4TF.png","size":137857,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C83S708.png","size":251088,"mtime":1757395176000,"ext":"png"},{"path":"Plates/GIX3162.png","size":184369,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KTDPNX4.png","size":87454,"mtime":1757395174000,"ext":"png"},{"path":"Plates/AE2DUT0.png","size":120363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZGYDJ5C.png","size":89532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S3R7YP8.png","size":244654,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S1CWQEC.png","size":89498,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PPX97K.png","size":139610,"mtime":1757395174000,"ext":"png"},{"path":"Plates/BUHUC1.png","size":117532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/B7F5T1Y.png","size":248043,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SQUCQ1.png","size":140293,"mtime":1757395174000,"ext":"png"},{"path":"Plates/R53DE3X.png","size":248527,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XB8PYW.png","size":139192,"mtime":1757395176000,"ext":"png"},{"path":"Plates/YY1PS2.png","size":236611,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JN2DF6.png","size":136942,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DV1K2Z.png","size":177258,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XP82WDL.png","size":243721,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SPQBUSK.png","size":120662,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MGGNAV.png","size":86897,"mtime":1757395174000,"ext":"png"},{"path":"MiniProject2_Meshach Samuel.docx","size":8068,"mtime":1764557243257,"ext":"docx"},{"path":"Mini Project 2.twbx","size":6509886,"mtime":1764598219199,"ext":"twbx"},{"path":"visualize_parking.py","size":7227,"mtime":1764556985701,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"},{"path":"map.png","size":110650,"mtime":1764552209823,"ext":"png"},{"path":"parking_visualization.png","size":230245,"mtime":1764555581485,"ext":"png"},{"path":"parking_animation.gif","size":2976487,"mtime":1764556944134,"ext":"gif"}],"modified":[],"removed":[],"experiment_id":"EXP00001"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:29:32.943Z","tree_hash":"474ab35bde1852820447290015f53456b1b3b90b12572bf5590f5661ba506065","added":[{"path":"parking_animation.gif","size":2976487,"mtime":1764556944134,"ext":"gif"},{"path":"map.png","size":110650,"mtime":1764552209823,"ext":"png"},{"path":"parking_visualization.png","size":230245,"mtime":1764555581485,"ext":"png"},{"path":"Mini Project 2.twbx","size":6509886,"mtime":1764598219199,"ext":"twbx"},{"path":"visualize_parking.py","size":7227,"mtime":1764556985701,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"},{"path":".cursorindexingignore","size":110,"mtime":1764553403640,"ext":""},{"path":"ride_hailing.xlsx","size":49230,"mtime":1764552222428,"ext":"xlsx"},{"path":"Plates/SPQBUSK.png","size":120662,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MGGNAV.png","size":86897,"mtime":1757395174000,"ext":"png"},{"path":"MiniProject2_Meshach Samuel.docx","size":8068,"mtime":1764557243257,"ext":"docx"},{"path":"Plates/DV1K2Z.png","size":177258,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XP82WDL.png","size":243721,"mtime":1757395176000,"ext":"png"},{"path":"Plates/JN2DF6.png","size":136942,"mtime":1757395176000,"ext":"png"},{"path":"Plates/YY1PS2.png","size":236611,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XB8PYW.png","size":139192,"mtime":1757395176000,"ext":"png"},{"path":"Plates/R53DE3X.png","size":248527,"mtime":1757395174000,"ext":"png"},{"path":"Plates/D7CN6Q.png","size":141521,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C2F6VN.png","size":138807,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WV610AS.png","size":251834,"mtime":1757395174000,"ext":"png"},{"path":"Plates/FE0MYMN.png","size":119098,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NCEUQ4.png","size":244976,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DD0BVK.png","size":231367,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M1FNYM.png","size":83630,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NVXWSP.png","size":245427,"mtime":1757395176000,"ext":"png"},{"path":"Plates/H3NFDTN.png","size":245068,"mtime":1757395176000,"ext":"png"},{"path":"Plates/T9GUBH.png","size":232263,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ZPR5EQ.png","size":240261,"mtime":1757395174000,"ext":"png"},{"path":"Plates/Q75Q706.png","size":88704,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JAS3UW.png","size":139414,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EU11YZ5.png","size":86458,"mtime":1757395176000,"ext":"png"},{"path":"Plates/D2FBZ7.png","size":135162,"mtime":1757395174000,"ext":"png"},{"path":"Plates/VS1CZZ6.png","size":184604,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LWPM9VY.png","size":253706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VEWCKJ.png","size":119745,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LPJW7B.png","size":118817,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MH6YC8.png","size":89091,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ULSXU1N.png","size":182443,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B5RMPS.png","size":138505,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CSUAPXD.png","size":186309,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B4BR8T.png","size":119963,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ENV245.png","size":136741,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J2GUWH8.png","size":121270,"mtime":1757395174000,"ext":"png"},{"path":"Plates/RHSDQR.png","size":139565,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NNLXDFC.png","size":238455,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F5SHUBE.png","size":119962,"mtime":1757395174000,"ext":"png"},{"path":"Plates/QEM62SJ.png","size":121752,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F2NJ2W.png","size":118100,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J1ZPXN.png","size":136545,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZJE033.png","size":239133,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CP5Q4M.png","size":89363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/GP93NR.png","size":140661,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XLCPAU8.png","size":252970,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CUQM88J.png","size":249810,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PCNHBH.png","size":231520,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DA7WK8.png","size":243177,"mtime":1757395176000,"ext":"png"},{"path":"Plates/U7R1JP.png","size":175690,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NADRE5G.png","size":120813,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XNC6FCM.png","size":242314,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PFB594.png","size":232538,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KG6EW2.png","size":89461,"mtime":1757395174000,"ext":"png"},{"path":"Plates/V73Q8J2.png","size":143920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VBTXTM.png","size":178067,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JUMX3RJ.png","size":248185,"mtime":1757395174000,"ext":"png"},{"path":"Plates/LLTYXL4.png","size":249205,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C7010N.png","size":85146,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CDBEJB.png","size":174697,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DHSQKAQ.png","size":119529,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FWZU4BU.png","size":139706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/E45LPU.png","size":134295,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WEBGFW1.png","size":86011,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EYELGK.png","size":83642,"mtime":1757395174000,"ext":"png"},{"path":"Plates/MHKVP5.png","size":120192,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PKS29HK.png","size":242629,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NSTQGMR.png","size":184318,"mtime":1757395176000,"ext":"png"},{"path":"Plates/UY767S.png","size":138706,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UUNJPK1.png","size":136920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WASDD1C.png","size":184748,"mtime":1757395174000,"ext":"png"},{"path":"Plates/H5BFXQR.png","size":120260,"mtime":1757395176000,"ext":"png"},{"path":"Plates/A8EFRA5.png","size":138824,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X9A1NUG.png","size":89290,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M2GC6BR.png","size":142782,"mtime":1757395174000,"ext":"png"},{"path":"Plates/K5RM40X.png","size":184771,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KGYDFK.png","size":85354,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PXAVN0E.png","size":184193,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XFCWC9.png","size":180415,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FEEN6D3.png","size":235557,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ALQWNF8.png","size":140989,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BQD3QCC.png","size":139180,"mtime":1757395174000,"ext":"png"},{"path":"Plates/WB28BTE.png","size":88148,"mtime":1757395174000,"ext":"png"},{"path":"Plates/HLTLM1.png","size":130915,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KK5UTE0.png","size":137813,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X7M262S.png","size":143047,"mtime":1757395174000,"ext":"png"},{"path":"Plates/YGYHQM3.png","size":242183,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PJ5RM4.png","size":120211,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BC9EGM.png","size":121179,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UPS7402.png","size":186223,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JXPN4TF.png","size":137857,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C83S708.png","size":251088,"mtime":1757395176000,"ext":"png"},{"path":"Plates/GIX3162.png","size":184369,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KTDPNX4.png","size":87454,"mtime":1757395174000,"ext":"png"},{"path":"Plates/AE2DUT0.png","size":120363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZGYDJ5C.png","size":89532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S3R7YP8.png","size":244654,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S1CWQEC.png","size":89498,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PPX97K.png","size":139610,"mtime":1757395174000,"ext":"png"},{"path":"Plates/BUHUC1.png","size":117532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/B7F5T1Y.png","size":248043,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SQUCQ1.png","size":140293,"mtime":1757395174000,"ext":"png"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:30:54.986Z","tree_hash":"474ab35bde1852820447290015f53456b1b3b90b12572bf5590f5661ba506065","added":[{"path":"parking_animation.gif","size":2976487,"mtime":1764556944134,"ext":"gif"},{"path":"parking_visualization.png","size":230245,"mtime":1764555581485,"ext":"png"},{"path":"visualize_parking.py","size":7227,"mtime":1764556985701,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [Line2D([0], [0], marker='o', color='w', label='Vacant', \n                          markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5)]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots as green dots\n    if not vacant_spots.empty:\n        ax.scatter(vacant_spots['x'], vacant_spots['plot_y'], \n                  c='green', alpha=0.7, s=80, zorder=1,\n                  edgecolors='black', linewidths=0.5)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"},{"path":"map.png","size":110650,"mtime":1764552209823,"ext":"png"},{"path":".cursorindexingignore","size":110,"mtime":1764553403640,"ext":""},{"path":"ride_hailing.xlsx","size":49230,"mtime":1764552222428,"ext":"xlsx"},{"path":"Mini Project 2.twbx","size":6509886,"mtime":1764598219199,"ext":"twbx"},{"path":"MiniProject2_Meshach Samuel.docx","size":8068,"mtime":1764557243257,"ext":"docx"},{"path":"Plates/XFCWC9.png","size":180415,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FEEN6D3.png","size":235557,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ALQWNF8.png","size":140989,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BQD3QCC.png","size":139180,"mtime":1757395174000,"ext":"png"},{"path":"Plates/WB28BTE.png","size":88148,"mtime":1757395174000,"ext":"png"},{"path":"Plates/HLTLM1.png","size":130915,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KK5UTE0.png","size":137813,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X7M262S.png","size":143047,"mtime":1757395174000,"ext":"png"},{"path":"Plates/YGYHQM3.png","size":242183,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PJ5RM4.png","size":120211,"mtime":1757395176000,"ext":"png"},{"path":"Plates/BC9EGM.png","size":121179,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UPS7402.png","size":186223,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JXPN4TF.png","size":137857,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C83S708.png","size":251088,"mtime":1757395176000,"ext":"png"},{"path":"Plates/GIX3162.png","size":184369,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KTDPNX4.png","size":87454,"mtime":1757395174000,"ext":"png"},{"path":"Plates/AE2DUT0.png","size":120363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZGYDJ5C.png","size":89532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S3R7YP8.png","size":244654,"mtime":1757395176000,"ext":"png"},{"path":"Plates/S1CWQEC.png","size":89498,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PPX97K.png","size":139610,"mtime":1757395174000,"ext":"png"},{"path":"Plates/BUHUC1.png","size":117532,"mtime":1757395176000,"ext":"png"},{"path":"Plates/B7F5T1Y.png","size":248043,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SQUCQ1.png","size":140293,"mtime":1757395174000,"ext":"png"},{"path":"Plates/R53DE3X.png","size":248527,"mtime":1757395174000,"ext":"png"},{"path":"Plates/XB8PYW.png","size":139192,"mtime":1757395176000,"ext":"png"},{"path":"Plates/YY1PS2.png","size":236611,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JN2DF6.png","size":136942,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DV1K2Z.png","size":177258,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XP82WDL.png","size":243721,"mtime":1757395176000,"ext":"png"},{"path":"Plates/SPQBUSK.png","size":120662,"mtime":1757395176000,"ext":"png"},{"path":"Plates/MGGNAV.png","size":86897,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CUQM88J.png","size":249810,"mtime":1757395176000,"ext":"png"},{"path":"Plates/PCNHBH.png","size":231520,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DA7WK8.png","size":243177,"mtime":1757395176000,"ext":"png"},{"path":"Plates/U7R1JP.png","size":175690,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NADRE5G.png","size":120813,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XNC6FCM.png","size":242314,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PFB594.png","size":232538,"mtime":1757395174000,"ext":"png"},{"path":"Plates/KG6EW2.png","size":89461,"mtime":1757395174000,"ext":"png"},{"path":"Plates/V73Q8J2.png","size":143920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VBTXTM.png","size":178067,"mtime":1757395174000,"ext":"png"},{"path":"Plates/JUMX3RJ.png","size":248185,"mtime":1757395174000,"ext":"png"},{"path":"Plates/LLTYXL4.png","size":249205,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C7010N.png","size":85146,"mtime":1757395176000,"ext":"png"},{"path":"Plates/CDBEJB.png","size":174697,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DHSQKAQ.png","size":119529,"mtime":1757395176000,"ext":"png"},{"path":"Plates/FWZU4BU.png","size":139706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/E45LPU.png","size":134295,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WEBGFW1.png","size":86011,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EYELGK.png","size":83642,"mtime":1757395174000,"ext":"png"},{"path":"Plates/MHKVP5.png","size":120192,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PKS29HK.png","size":242629,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NSTQGMR.png","size":184318,"mtime":1757395176000,"ext":"png"},{"path":"Plates/UY767S.png","size":138706,"mtime":1757395174000,"ext":"png"},{"path":"Plates/UUNJPK1.png","size":136920,"mtime":1757395176000,"ext":"png"},{"path":"Plates/WASDD1C.png","size":184748,"mtime":1757395174000,"ext":"png"},{"path":"Plates/H5BFXQR.png","size":120260,"mtime":1757395176000,"ext":"png"},{"path":"Plates/D7CN6Q.png","size":141521,"mtime":1757395176000,"ext":"png"},{"path":"Plates/A8EFRA5.png","size":138824,"mtime":1757395174000,"ext":"png"},{"path":"Plates/X9A1NUG.png","size":89290,"mtime":1757395176000,"ext":"png"},{"path":"Plates/C2F6VN.png","size":138807,"mtime":1757395176000,"ext":"png"},{"path":"Plates/M2GC6BR.png","size":142782,"mtime":1757395174000,"ext":"png"},{"path":"Plates/WV610AS.png","size":251834,"mtime":1757395174000,"ext":"png"},{"path":"Plates/K5RM40X.png","size":184771,"mtime":1757395174000,"ext":"png"},{"path":"Plates/FE0MYMN.png","size":119098,"mtime":1757395176000,"ext":"png"},{"path":"Plates/KGYDFK.png","size":85354,"mtime":1757395174000,"ext":"png"},{"path":"Plates/PXAVN0E.png","size":184193,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ULSXU1N.png","size":182443,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B5RMPS.png","size":138505,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CSUAPXD.png","size":186309,"mtime":1757395174000,"ext":"png"},{"path":"Plates/B4BR8T.png","size":119963,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ENV245.png","size":136741,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J2GUWH8.png","size":121270,"mtime":1757395174000,"ext":"png"},{"path":"Plates/RHSDQR.png","size":139565,"mtime":1757395174000,"ext":"png"},{"path":"Plates/NNLXDFC.png","size":238455,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F5SHUBE.png","size":119962,"mtime":1757395174000,"ext":"png"},{"path":"Plates/QEM62SJ.png","size":121752,"mtime":1757395174000,"ext":"png"},{"path":"Plates/F2NJ2W.png","size":118100,"mtime":1757395174000,"ext":"png"},{"path":"Plates/J1ZPXN.png","size":136545,"mtime":1757395174000,"ext":"png"},{"path":"Plates/ZJE033.png","size":239133,"mtime":1757395174000,"ext":"png"},{"path":"Plates/CP5Q4M.png","size":89363,"mtime":1757395174000,"ext":"png"},{"path":"Plates/GP93NR.png","size":140661,"mtime":1757395176000,"ext":"png"},{"path":"Plates/XLCPAU8.png","size":252970,"mtime":1757395176000,"ext":"png"},{"path":"Plates/JAS3UW.png","size":139414,"mtime":1757395176000,"ext":"png"},{"path":"Plates/EU11YZ5.png","size":86458,"mtime":1757395176000,"ext":"png"},{"path":"Plates/D2FBZ7.png","size":135162,"mtime":1757395174000,"ext":"png"},{"path":"Plates/VS1CZZ6.png","size":184604,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LWPM9VY.png","size":253706,"mtime":1757395176000,"ext":"png"},{"path":"Plates/H3NFDTN.png","size":245068,"mtime":1757395176000,"ext":"png"},{"path":"Plates/VEWCKJ.png","size":119745,"mtime":1757395176000,"ext":"png"},{"path":"Plates/T9GUBH.png","size":232263,"mtime":1757395176000,"ext":"png"},{"path":"Plates/LPJW7B.png","size":118817,"mtime":1757395176000,"ext":"png"},{"path":"Plates/ZPR5EQ.png","size":240261,"mtime":1757395174000,"ext":"png"},{"path":"Plates/MH6YC8.png","size":89091,"mtime":1757395176000,"ext":"png"},{"path":"Plates/Q75Q706.png","size":88704,"mtime":1757395174000,"ext":"png"},{"path":"Plates/M1FNYM.png","size":83630,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NVXWSP.png","size":245427,"mtime":1757395176000,"ext":"png"},{"path":"Plates/DD0BVK.png","size":231367,"mtime":1757395176000,"ext":"png"},{"path":"Plates/NCEUQ4.png","size":244976,"mtime":1757395176000,"ext":"png"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:37:15.154Z","tree_hash":"3fee1d4f8a34d120109527f952046ae35771afc795748ba947e32a4c0f740bf7","added":[{"path":"README.md","size":23,"mtime":1765417034478,"ext":"md","content":"# CIS-541-MiniProject3\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:41:15.267Z","tree_hash":"26c2e39dca2b3a9c356292fb1ca06c725df12fbfb5f46014f000b462f60400ba","added":[],"modified":[{"path":"visualize_parking.py","size":8271,"mtime":1765417272590,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:42:05.283Z","tree_hash":"89505684738b125b85eaea21ecbf9305f88dd1f2c18ac0c8aac568858e9ea907","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765417325060,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:42:10.288Z","tree_hash":"7b810476b15a4eb488f21e900f23d7f1d47995f781966cace73cb4b2f397d986","added":[],"modified":[{"path":"parking_animation.gif","size":2414862,"mtime":1765417327987,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:45:20.357Z","tree_hash":"d0cb493ed7da8eb5c880e26120f31d58cbdf9a578ab63c08c5623f35936c3b35","added":[],"modified":[{"path":"visualize_parking.py","size":8773,"mtime":1765417518188,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='gold', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates estimated as near (50, 50) based on \"top left arrow base\" description\n    entrance_x, entrance_y = 50, 50\n    ax.scatter(entrance_x, entrance_y, c='gold', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5, marker='*')\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:45:40.364Z","tree_hash":"72cd515d654b3a50eaa15785d34b764cc1af85514ec6fa4af3a3614c85280e4b","added":[],"modified":[{"path":"parking_animation.gif","size":2508989,"mtime":1765417539019,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:46:40.390Z","tree_hash":"f330e71a60b342f0921cd6d38597f1980554888d7474a87441cffa0a82c48ada","added":[],"modified":[{"path":"visualize_parking.py","size":8753,"mtime":1765417599850,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='blue', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 300, 50\n    ax.scatter(entrance_x, entrance_y, c='blue', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:47:00.401Z","tree_hash":"1064c906629ec7c62976e5ee183f4ea1a0715df7af0c20106853984307fd99bb","added":[],"modified":[{"path":"parking_animation.gif","size":3095424,"mtime":1765417620181,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:47:30.355Z","tree_hash":"fee9de83d0485e46a24639565a7009705832693775bed6f08474a5a57b9d155b","added":[],"modified":[{"path":"visualize_parking.py","size":8753,"mtime":1765417647645,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='blue', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 250, 50\n    ax.scatter(entrance_x, entrance_y, c='blue', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:47:50.361Z","tree_hash":"38a1af7556c142bbadd3dababb4a2769e7a79cbdc47c2bd67d34f2b29c444d47","added":[],"modified":[{"path":"parking_animation.gif","size":3101495,"mtime":1765417670158,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:48:25.372Z","tree_hash":"254ffb12f65b5fc34156302276a230f280a093828b1988ed16f80343f44a9bb4","added":[],"modified":[{"path":"visualize_parking.py","size":8753,"mtime":1765417702022,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='blue', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 240, 50\n    ax.scatter(entrance_x, entrance_y, c='blue', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:48:45.382Z","tree_hash":"50dfc6cfe41525acb2723adf12eb824b0739cc76bd15c87a9fe61ae25fcff09e","added":[],"modified":[{"path":"parking_animation.gif","size":3103013,"mtime":1765417722940,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:49:05.391Z","tree_hash":"df36dabc92c7d519c94004767c7dd35fd0460d59f14479f9d592ee898fa00be7","added":[],"modified":[{"path":"visualize_parking.py","size":8753,"mtime":1765417740850,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='blue', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 230, 50\n    ax.scatter(entrance_x, entrance_y, c='blue', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:49:20.394Z","tree_hash":"b42d15dc52c4fc593087af06b989f75215f27d8e3d3b74a4aa6528e2f9cea4f2","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765417758845,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:49:25.398Z","tree_hash":"2607c86c36cd394f5c2037cd10f0028c8bfec705542bee782c46c767787ec0e2","added":[],"modified":[{"path":"parking_animation.gif","size":3103927,"mtime":1765417761481,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:49:40.401Z","tree_hash":"8ad0178dba1800352fd5d85fe0962f118aab1765f3b9b071b069196601a65252","added":[],"modified":[{"path":"visualize_parking.py","size":8753,"mtime":1765417778303,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='blue', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='blue', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:50:00.407Z","tree_hash":"1bb23e5e78af9585c72913a315c53349c191b7f4354d2d0ad0356eb9dd8c9868","added":[],"modified":[{"path":"parking_animation.gif","size":3104054,"mtime":1765417799113,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:50:20.412Z","tree_hash":"ed8204a05875d9f23752336291c36e5e6b2bbc534be5c8411caa1af87ca38d95","added":[],"modified":[{"path":"visualize_parking.py","size":8753,"mtime":1765417819675,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5)\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:50:40.420Z","tree_hash":"aa7b9b6b1ba7ee41ae89c5ac1c70cb2240432f8759e65add07dbc9c053b29c7f","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765417838127,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:50:45.425Z","tree_hash":"be7a6d80643ddc718a13ad4fd24956342384369e6802f2dd86047594c2d8b09c","added":[],"modified":[{"path":"parking_animation.gif","size":2476779,"mtime":1765417840955,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:52:15.467Z","tree_hash":"5bd301ec542e37243928c5999cf09ff2ea6a0792817cf4fe60ec2c92eb931ac9","added":[],"modified":[{"path":"visualize_parking.py","size":9244,"mtime":1765417935286,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='cyan', linestyle='--', linewidth=2, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n        # Draw path from entrance to nearest vacant spot\n        # Entrance coordinates are defined below, but we use the values here\n        ent_x, ent_y = 225, 50\n        path_x = [ent_x, nearest_spot['x'].values[0]]\n        path_y = [ent_y, nearest_spot['plot_y'].values[0]]\n        \n        ax.plot(path_x, path_y, color='cyan', linestyle='--', linewidth=2, zorder=1.5, alpha=0.8)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:52:35.479Z","tree_hash":"4f5fe3bd0b1a4a2035b5c1f65bc40745605dabcb9375810befe6fd9b4ef256e2","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765417954032,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:52:40.480Z","tree_hash":"255f5e847dae67529d61c45fc2d063529217ca41c7386172c5c36ed39239e3ba","added":[],"modified":[{"path":"parking_animation.gif","size":2865932,"mtime":1765417956912,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:53:55.507Z","tree_hash":"f5932f4edcd47b06920c3e84eb2b6a5dc2727395597f123ac882a479233c112e","added":[],"modified":[{"path":"visualize_parking.py","size":9250,"mtime":1765418031357,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=2.5, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n        # Draw path from entrance to nearest vacant spot\n        # Entrance coordinates are defined below, but we use the values here\n        ent_x, ent_y = 225, 50\n        path_x = [ent_x, nearest_spot['x'].values[0]]\n        path_y = [ent_y, nearest_spot['plot_y'].values[0]]\n        \n        ax.plot(path_x, path_y, color='yellow', linestyle='-', linewidth=2.5, zorder=1.5, alpha=0.9)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:54:10.517Z","tree_hash":"eecfad732fd48cb4ac20943a9cb4a6acd88842eb41a35b46a6af24cef5307495","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765418050045,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:54:15.519Z","tree_hash":"3d61f4676e73193e69abc4d49fcb51f067c9e8cc3f9dce8b9a68ab35b5168530","added":[],"modified":[{"path":"parking_animation.gif","size":2519778,"mtime":1765418052963,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:55:35.547Z","tree_hash":"7b45fa445417392a955636395bc6cd50e16320649d791cbca569333f7e7e6926","added":[],"modified":[{"path":"visualize_parking.py","size":9346,"mtime":1765418130797,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=2.5, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n        # Draw path from entrance to nearest vacant spot\n        # Entrance coordinates are defined below, but we use the values here\n        ent_x, ent_y = 225, 50\n        path_x = [ent_x, nearest_spot['x'].values[0]]\n        path_y = [ent_y, nearest_spot['plot_y'].values[0]]\n        \n        ax.plot(path_x, path_y, color='yellow', linestyle='-', linewidth=2.5, zorder=1.5, alpha=0.9)\n    \n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    # Plot entering vehicle marker (static at top-left entrance)\n    # Coordinates updated based on user feedback (blue dot, more to the right)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:55:50.553Z","tree_hash":"524e5850a0bdbffb8ce9072ba3294a563f20b99a14b81142511d10f253573fac","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765418149122,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:55:55.556Z","tree_hash":"af7621eaddcf2de2733ec22317f7dbfeda599e9d07e44ade5a149115656f83cd","added":[],"modified":[{"path":"parking_animation.gif","size":2442717,"mtime":1765418151917,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:58:50.611Z","tree_hash":"0ec508bbaf98861883cf04d10bc1003d70343fb1b3f0b7f77d330fcaea57dc19","added":[],"modified":[{"path":"visualize_parking.py","size":9383,"mtime":1765418328654,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=2.5, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n    # Plot entering vehicle marker (static at top-left entrance)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    # Calculate and draw street-like path to nearest vacant spot\n    if not vacant_spots.empty:\n        # Get target coordinates\n        target_x = nearest_spot['x'].values[0]\n        target_y = nearest_spot['plot_y'].values[0]\n        \n        # Define parking aisles x-coordinates\n        # Left block (420, 600) -> Aisle at 510\n        # Right block (973, 1157) -> Aisle at 1065\n        aisle_1_x = 510\n        aisle_2_x = 1065\n        \n        # Determine which aisle is closer to the target\n        if abs(target_x - aisle_1_x) < abs(target_x - aisle_2_x):\n            chosen_aisle_x = aisle_1_x\n        else:\n            chosen_aisle_x = aisle_2_x\n            \n        # Define waypoints for the path\n        # 1. Start at entrance\n        # 2. Move horizontally to the chosen aisle (at top level y=50)\n        # 3. Move vertically down the aisle to the target row (y=target_y)\n        # 4. Move horizontally to the target spot\n        \n        path_points_x = [entrance_x, chosen_aisle_x, chosen_aisle_x, target_x]\n        path_points_y = [entrance_y, entrance_y, target_y, target_y]\n        \n        ax.plot(path_points_x, path_points_y, color='yellow', linestyle='-', \n               linewidth=2.5, zorder=1.5, alpha=0.9)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:59:15.619Z","tree_hash":"d31c9f40e20f56b6d04783f985320d88f029d1d782d39af0df2988a523714d3f","added":[],"modified":[{"path":"visualize_parking.py","size":10106,"mtime":1765418354492,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=2.5, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n    # Plot entering vehicle marker (static at top-left entrance)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    # Calculate and draw street-like path to nearest vacant spot\n    if not vacant_spots.empty:\n        # Get target coordinates\n        target_x = nearest_spot['x'].values[0]\n        target_y = nearest_spot['plot_y'].values[0]\n        \n        # Define parking aisles x-coordinates\n        # Left block (420, 600) -> Aisle at 510\n        # Right block (973, 1157) -> Aisle at 1065\n        aisle_1_x = 510\n        aisle_2_x = 1065\n        \n        # Determine which aisle is closer to the target\n        if abs(target_x - aisle_1_x) < abs(target_x - aisle_2_x):\n            chosen_aisle_x = aisle_1_x\n        else:\n            chosen_aisle_x = aisle_2_x\n            \n        # Define waypoints for the path\n        # 1. Start at entrance\n        # 2. Move horizontally to the chosen aisle (at top level y=50)\n        # 3. Move vertically down the aisle to the target row (y=target_y)\n        # 4. Move horizontally to the target spot\n        \n        path_points_x = [entrance_x, chosen_aisle_x, chosen_aisle_x, target_x]\n        path_points_y = [entrance_y, entrance_y, target_y, target_y]\n        \n        ax.plot(path_points_x, path_points_y, color='yellow', linestyle='-', \n               linewidth=2.5, zorder=1.5, alpha=0.9)\n\n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:59:35.630Z","tree_hash":"368a3dbd908cc10b5eb27b60848d4d68e5fbc17bf7fa8b0c973a4cf7d6f6556c","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765418373566,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T01:59:40.633Z","tree_hash":"9bf4584cbc606b4bb847d1331f407f7ebe83ea44aacb9c006d71b0fcfbe05ea0","added":[],"modified":[{"path":"parking_animation.gif","size":2363076,"mtime":1765418376442,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:04:00.743Z","tree_hash":"bc88036d86318658b2fdc76a10a60ebeba8c666a70ddfbeb9a1351f0d084f694","added":[],"modified":[{"path":"visualize_parking.py","size":10669,"mtime":1765418640422,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=2.5, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n    # Plot entering vehicle marker (static at top-left entrance)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    # Calculate and draw street-like path to nearest vacant spot\n    if not vacant_spots.empty:\n        # Get target coordinates\n        target_x = nearest_spot['x'].values[0]\n        target_y = nearest_spot['plot_y'].values[0]\n        \n        # Define aisles based on slot X-coordinate clusters\n        # Layout hypothesis:\n        # - Road 1 (Left): ~320 (Serves slots at 420)\n        # - Road 2 (Middle): ~790 (Serves slots at 600 and 973)\n        # - Road 3 (Right): ~1250 (Serves slots at 1157)\n        \n        target_x_val = target_x\n        \n        # Determine appropriate aisle X-coordinate\n        # Note: Entrance is at X=225\n        if target_x_val < 500:       # Slot at 420\n            aisle_x = 320\n        elif target_x_val < 800:     # Slot at 600\n            aisle_x = 790\n        elif target_x_val < 1050:    # Slot at 973\n            aisle_x = 790\n        else:                        # Slot at 1157\n            aisle_x = 1250\n            \n        # Define waypoints for the path\n        # 1. Start at entrance\n        # 2. Move horizontally to the designated aisle (at top level y=50)\n        # 3. Move vertically down the aisle to the target row (y=target_y)\n        # 4. Move horizontally to the target spot\n        \n        # Determine direction to move horizontally to spot\n        # Not strictly needed for line drawing, but contextually:\n        # - From 320 to 420: Right\n        # - From 790 to 600: Left\n        # - From 790 to 973: Right\n        # - From 1250 to 1157: Left\n        \n        path_points_x = [entrance_x, aisle_x, aisle_x, target_x_val]\n        path_points_y = [entrance_y, entrance_y, target_y, target_y]\n        \n        ax.plot(path_points_x, path_points_y, color='yellow', linestyle='-', \n               linewidth=2.5, zorder=1.5, alpha=0.9)\n\n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:04:20.748Z","tree_hash":"b7be5d4efcfe41ad4b1da701656212e23c4b674a7e0837666cef90cbb757c694","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765418659613,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:04:25.751Z","tree_hash":"7a05c99fc7a6999ff6a751e5f7d7e6e4066a8a624ddee8099b5137c439ac73f2","added":[],"modified":[{"path":"parking_animation.gif","size":2354664,"mtime":1765418662493,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:08:30.842Z","tree_hash":"597a5154fda8eb56d1d5e894212f3fe9691e3679a41ff80d4d89d43cf491ceaa","added":[],"modified":[{"path":"visualize_parking.py","size":11229,"mtime":1765418909205,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=2.5, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n    # Plot entering vehicle marker (static at top-left entrance)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    # Calculate and draw street-like path to nearest vacant spot\n    if not vacant_spots.empty:\n        # Get target coordinates\n        target_x = nearest_spot['x'].values[0]\n        target_y = nearest_spot['plot_y'].values[0]\n        \n        # Define aisles and routing based on slot clusters\n        # Layout hypothesis based on user feedback:\n        # Structure 1 (Left): Slots approx 420 and 600\n        # Structure 2 (Right): Slots approx 973 and 1157\n        #\n        # Roads:\n        # - Road 1 (Leftmost): Aligned with entrance at ~225. Serves X=420.\n        # - Road 2 (Middle): ~790. Serves X=600 and X=973.\n        # - Road 3 (Rightmost): ~1250. Serves X=1157.\n        \n        target_x_val = target_x\n        \n        if target_x_val < 500:\n            # Case 1: Left Structure, Left Side (X=420)\n            # Rule: Path comes strictly downwards from entrance, then turn.\n            # Aisle is the entrance column itself (225).\n            \n            # Waypoints:\n            # 1. Start at entrance (225, 50)\n            # 2. Move VERTICALLY down to target row (225, target_y)\n            # 3. Move HORIZONTALLY to target spot (420, target_y)\n            path_points_x = [entrance_x, entrance_x, target_x_val]\n            path_points_y = [entrance_y, target_y, target_y]\n            \n        else:\n            # All other cases involve moving horizontally to a different aisle first\n            if target_x_val < 800:     # Slot at 600 (Left Struct, Right Side)\n                aisle_x = 790          # Use Middle Road\n            elif target_x_val < 1050:  # Slot at 973 (Right Struct, Left Side)\n                aisle_x = 790          # Use Middle Road\n            else:                      # Slot at 1157 (Right Struct, Right Side)\n                aisle_x = 1250         # Use Right Road\n            \n            # Waypoints:\n            # 1. Start at entrance\n            # 2. Move HORIZONTALLY to designated aisle (aisle_x, 50)\n            # 3. Move VERTICALLY down aisle (aisle_x, target_y)\n            # 4. Move HORIZONTALLY to target spot\n            path_points_x = [entrance_x, aisle_x, aisle_x, target_x_val]\n            path_points_y = [entrance_y, entrance_y, target_y, target_y]\n        \n        ax.plot(path_points_x, path_points_y, color='yellow', linestyle='-', \n               linewidth=2.5, zorder=1.5, alpha=0.9)\n\n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:08:50.849Z","tree_hash":"3fef0a50701d33458bd0e811adb34ac31e5bc51f09e76ac7efbbefb9d00e04af","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765418928677,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:08:55.852Z","tree_hash":"5b9dcad73f93d92e82c2252c38fcfb0d98165cd8e113f32b9cebd2c69d1c30d2","added":[],"modified":[{"path":"parking_animation.gif","size":2323970,"mtime":1765418931559,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:10:30.888Z","tree_hash":"e0a7a5f4c285f8b49c9908b3ac5a568323288ce31a69691e4dee13c597dc568a","added":[],"modified":[{"path":"visualize_parking.py","size":11455,"mtime":1765419030573,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=2.5, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=100, zorder=2,\n                  edgecolors='black', linewidths=1.0)\n                  \n    # Plot entering vehicle marker (static at top-left entrance)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=150, \n              zorder=3, edgecolors='black', linewidths=1.5)\n    \n    # Calculate and draw street-like path to nearest vacant spot\n    if not vacant_spots.empty:\n        # Get target coordinates\n        target_x = nearest_spot['x'].values[0]\n        target_y = nearest_spot['plot_y'].values[0]\n        \n        # Define aisles and routing based on slot clusters\n        # Layout hypothesis based on user feedback:\n        # Structure 1 (Left): Slots approx 420 and 600\n        # Structure 2 (Right): Slots approx 973 and 1157\n        #\n        # Roads:\n        # - Road 1 (Leftmost): Aligned with entrance at ~225. Serves X=420.\n        # - Road 2 (Middle): ~790. Serves X=600 and X=973.\n        # - Road 3 (Rightmost): ~1250. Serves X=1157.\n        \n        target_x_val = target_x\n        \n        if target_x_val < 500:\n            # Case 1: Left Structure, Left Side (X=420)\n            # Rule: Path comes strictly downwards from entrance, then turn.\n            # Aisle is the entrance column itself (225).\n            \n            # Waypoints:\n            # 1. Start at entrance (225, 50)\n            # 2. Move VERTICALLY down to target row (225, target_y)\n            # 3. Move HORIZONTALLY to target spot (420, target_y)\n            path_points_x = [entrance_x, entrance_x, target_x_val]\n            path_points_y = [entrance_y, target_y, target_y]\n            \n        else:\n            # All other cases involve moving horizontally to a different aisle first\n            if target_x_val < 800:     # Slot at 600 (Left Struct, Right Side)\n                aisle_x = 790          # Use Middle Road\n            elif target_x_val < 1050:  # Slot at 973 (Right Struct, Left Side)\n                aisle_x = 790          # Use Middle Road\n            else:                      # Slot at 1157 (Right Struct, Right Side)\n                aisle_x = 1250         # Use Right Road\n            \n            # Waypoints:\n            # 1. Start at entrance (225, 50)\n            # 2. Move VERTICALLY down (Forward) to cross-road level (225, 160)\n            #    (User requested \"go forward first then make the left turn\")\n            # 3. Move HORIZONTALLY to designated aisle (aisle_x, 160)\n            # 4. Move VERTICALLY down aisle (aisle_x, target_y)\n            # 5. Move HORIZONTALLY to target spot\n            cross_road_y = 160\n            path_points_x = [entrance_x, entrance_x, aisle_x, aisle_x, target_x_val]\n            path_points_y = [entrance_y, cross_road_y, cross_road_y, target_y, target_y]\n        \n        ax.plot(path_points_x, path_points_y, color='yellow', linestyle='-', \n               linewidth=2.5, zorder=1.5, alpha=0.9)\n\n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:10:55.899Z","tree_hash":"eaa5f3979a7b6b25c855adb90d43d2487294ab1bc37d171dadf650af48c68a55","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765419053816,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:11:00.899Z","tree_hash":"e1a5eeed22fb29f7ce176d4c082398437f43e77d09c3b05d807d7cca360fd4ad","added":[],"modified":[{"path":"parking_animation.gif","size":2324388,"mtime":1765419056677,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:12:15.928Z","tree_hash":"349f35332f3aea9f783ce5759a52181bbcb857ee68eb68c90bf1123c9f070f69","added":[],"modified":[{"path":"visualize_parking.py","size":11472,"mtime":1765419133722,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=15, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=15, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=4.0, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot (increased size)\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=200, zorder=2,\n                  edgecolors='black', linewidths=1.5)\n                  \n    # Plot entering vehicle marker (static at top-left entrance)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=250, \n              zorder=3, edgecolors='black', linewidths=2.0)\n    \n    # Calculate and draw street-like path to nearest vacant spot\n    if not vacant_spots.empty:\n        # Get target coordinates\n        target_x = nearest_spot['x'].values[0]\n        target_y = nearest_spot['plot_y'].values[0]\n        \n        # Define aisles and routing based on slot clusters\n        # Layout hypothesis based on user feedback:\n        # Structure 1 (Left): Slots approx 420 and 600\n        # Structure 2 (Right): Slots approx 973 and 1157\n        #\n        # Roads:\n        # - Road 1 (Leftmost): Aligned with entrance at ~225. Serves X=420.\n        # - Road 2 (Middle): ~790. Serves X=600 and X=973.\n        # - Road 3 (Rightmost): ~1250. Serves X=1157.\n        \n        target_x_val = target_x\n        \n        if target_x_val < 500:\n            # Case 1: Left Structure, Left Side (X=420)\n            # Rule: Path comes strictly downwards from entrance, then turn.\n            # Aisle is the entrance column itself (225).\n            \n            # Waypoints:\n            # 1. Start at entrance (225, 50)\n            # 2. Move VERTICALLY down to target row (225, target_y)\n            # 3. Move HORIZONTALLY to target spot (420, target_y)\n            path_points_x = [entrance_x, entrance_x, target_x_val]\n            path_points_y = [entrance_y, target_y, target_y]\n            \n        else:\n            # All other cases involve moving horizontally to a different aisle first\n            if target_x_val < 800:     # Slot at 600 (Left Struct, Right Side)\n                aisle_x = 790          # Use Middle Road\n            elif target_x_val < 1050:  # Slot at 973 (Right Struct, Left Side)\n                aisle_x = 790          # Use Middle Road\n            else:                      # Slot at 1157 (Right Struct, Right Side)\n                aisle_x = 1250         # Use Right Road\n            \n            # Waypoints:\n            # 1. Start at entrance (225, 50)\n            # 2. Move VERTICALLY down (Forward) to cross-road level (225, 160)\n            #    (User requested \"go forward first then make the left turn\")\n            # 3. Move HORIZONTALLY to designated aisle (aisle_x, 160)\n            # 4. Move VERTICALLY down aisle (aisle_x, target_y)\n            # 5. Move HORIZONTALLY to target spot\n            cross_road_y = 160\n            path_points_x = [entrance_x, entrance_x, aisle_x, aisle_x, target_x_val]\n            path_points_y = [entrance_y, cross_road_y, cross_road_y, target_y, target_y]\n        \n        ax.plot(path_points_x, path_points_y, color='yellow', linestyle='-', \n               linewidth=4.0, zorder=1.5, alpha=0.9)\n\n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:12:35.931Z","tree_hash":"0539914bb550ca017ef1b805482e57b4d3fac49711fc56b29e68816397c736fc","added":[],"modified":[{"path":"parking_animation.gif","size":2661757,"mtime":1765419155509,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:16:25.981Z","tree_hash":"1aa6b5327bb4f6ba4d1e346ebdc7d0ac0697c50779fd0542e29479a86d6395dd","added":[],"modified":[],"removed":[{"path":"Mini Project 2.twbx","size":0,"mtime":0,"ext":"twbx","content":null},{"path":"MiniProject2_Meshach Samuel.docx","size":0,"mtime":0,"ext":"docx","content":null}],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL21lc2hh","ts":"2025-12-11T02:16:35.982Z","tree_hash":"0d56e0f4e37a78623ac4a435d3f68e1400470cbeef1878b60b689c72d9a80e32","added":[],"modified":[{"path":"visualize_parking.py","size":11472,"mtime":1765419394742,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom PIL import Image\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\n# Load Data: Read the Excel File into a pandas DataFrame\ndf = pd.read_excel('ride_hailing.xlsx')\n\n# Basic Processing:\n# Create a new column called Status. If the reservation_id column has any text or number in it, \n# the status should be 'occupied'. otherwise it should be 'vacant'\ndf['Status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\n# Make sure the current_time column is understood by the program as a date and time\ndf['current_time'] = pd.to_datetime(df['current_time'])\n\n# Get all 24 slot positions (coordinates are consistent across timestamps)\nslot_positions = df.dropna(subset=['x', 'y']).groupby('slot_id')[['x', 'y']].first().reset_index()\n\n# Get all unique timestamps and sort them\nunique_timestamps = sorted(df['current_time'].unique())\nprint(f\"Found {len(unique_timestamps)} unique timestamps\")\n\n# Load background image and flip it vertically\nbg_image = Image.open('map.png')\nimg_width, img_height = bg_image.size\n# Flip the image vertically so it displays correctly\nbg_image = bg_image.transpose(Image.FLIP_TOP_BOTTOM)\n\n# Transform y-coordinates to match the flipped image\nslot_positions['plot_y'] = img_height - slot_positions['y']\n\n# Generate figure and axis (will be reused for each frame)\nfig, ax = plt.subplots(figsize=(16, 12))\n\n# Display background image (same for all frames)\nax.imshow(bg_image, extent=[0, img_width, 0, img_height],\n          aspect='equal', zorder=0, origin='upper')\n\n# Set axis limits - invert y-axis to match the flipped image and coordinates\nax.set_xlim(0, img_width)\nax.set_ylim(img_height, 0)  # Inverted: y=0 at top\n\n# Remove white background and grid lines\nax.set_facecolor('none')\nax.grid(False)\n\n# Hide x and y axis numbers and ticks\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\n\n# Remove axis spines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Add legend (same for all frames)\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='Vacant', \n           markerfacecolor='green', markersize=10, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Nearest Vacant', \n           markerfacecolor='orange', markersize=15, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], marker='o', color='w', label='Entering Vehicle', \n           markerfacecolor='cyan', markersize=15, markeredgecolor='black', markeredgewidth=0.5),\n    Line2D([0], [0], color='yellow', linestyle='-', linewidth=4.0, label='Path to Spot')\n]\nlegend_obj = ax.legend(handles=legend_elements, loc='upper right', fontsize=12, framealpha=0.9)\n\n# Store references to dynamic elements that will be updated\ntitle_text_obj = ax.text(0.5, 1.02, '', transform=ax.transAxes, \n                         fontsize=16, fontweight='bold', ha='center', va='bottom')\n\ndef load_plate_image(plate_number, zoom=0.15):\n    \"\"\"Load and prepare a license plate image for annotation.\"\"\"\n    plate_path = f'Plates/{plate_number}.png'\n    if os.path.exists(plate_path):\n        img = Image.open(plate_path)\n        return OffsetImage(img, zoom=zoom)\n    return None\n\ndef animate_frame(frame_num):\n    \"\"\"Function to draw each frame of the animation.\"\"\"\n    # Clear scatter plots (collections)\n    while ax.collections:\n        ax.collections[0].remove()\n    \n    # Remove all annotation artists (AnnotationBbox objects are added as artists)\n    # Title text is in ax.texts, not ax.artists, so safe to clear all artists\n    while ax.artists:\n        ax.artists[0].remove()\n\n    # Clear lines (paths) from previous frame\n    while ax.lines:\n        ax.lines[0].remove()\n    \n    # Get current timestamp\n    current_timestamp = unique_timestamps[frame_num]\n    \n    # Update title\n    title_text_obj.set_text(f'Parking Status Visualization - {current_timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n    \n    # Filter data for current timestamp\n    timestamp_data = df[df['current_time'] == current_timestamp].copy()\n    \n    # Calculate status for each slot at this timestamp\n    timestamp_data['Status'] = timestamp_data['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    # Merge slot positions with status data\n    slot_status = timestamp_data[['slot_id', 'Status', 'plate_number']].drop_duplicates('slot_id', keep='last')\n    \n    # Combine positions with status - all 24 slots should be shown\n    plot_df = slot_positions.merge(slot_status, on='slot_id', how='left')\n    plot_df['Status'] = plot_df['Status'].fillna('vacant')  # Default to vacant if no data\n    \n    # Separate occupied and vacant spots\n    occupied_spots = plot_df[plot_df['Status'] == 'occupied'].copy()\n    vacant_spots = plot_df[plot_df['Status'] == 'vacant'].copy()\n    \n    # Plot vacant spots\n    if not vacant_spots.empty:\n        # Calculate distance from top-left (0, 0) for each vacant spot\n        # Using Euclidean distance: sqrt(x^2 + y^2)\n        # Note: We use plot_y which corresponds to the visual coordinates\n        vacant_spots['distance'] = np.sqrt(vacant_spots['x']**2 + vacant_spots['plot_y']**2)\n        \n        # Find the index of the nearest spot\n        nearest_idx = vacant_spots['distance'].idxmin()\n        \n        # Split into nearest and others\n        nearest_spot = vacant_spots.loc[[nearest_idx]]\n        other_vacant = vacant_spots.drop(nearest_idx)\n        \n        # Plot other vacant spots as green dots\n        if not other_vacant.empty:\n            ax.scatter(other_vacant['x'], other_vacant['plot_y'], \n                      c='green', alpha=0.7, s=80, zorder=1,\n                      edgecolors='black', linewidths=0.5)\n            \n        # Plot nearest vacant spot as orange dot (increased size)\n        ax.scatter(nearest_spot['x'], nearest_spot['plot_y'], \n                  c='orange', alpha=0.9, s=200, zorder=2,\n                  edgecolors='black', linewidths=1.5)\n                  \n    # Plot entering vehicle marker (static at top-left entrance)\n    entrance_x, entrance_y = 225, 50\n    ax.scatter(entrance_x, entrance_y, c='cyan', alpha=1.0, s=250, \n              zorder=3, edgecolors='black', linewidths=2.0)\n    \n    # Calculate and draw street-like path to nearest vacant spot\n    if not vacant_spots.empty:\n        # Get target coordinates\n        target_x = nearest_spot['x'].values[0]\n        target_y = nearest_spot['plot_y'].values[0]\n        \n        # Define aisles and routing based on slot clusters\n        # Layout hypothesis based on user feedback:\n        # Structure 1 (Left): Slots approx 420 and 600\n        # Structure 2 (Right): Slots approx 973 and 1157\n        #\n        # Roads:\n        # - Road 1 (Leftmost): Aligned with entrance at ~225. Serves X=420.\n        # - Road 2 (Middle): ~790. Serves X=600 and X=973.\n        # - Road 3 (Rightmost): ~1250. Serves X=1157.\n        \n        target_x_val = target_x\n        \n        if target_x_val < 500:\n            # Case 1: Left Structure, Left Side (X=420)\n            # Rule: Path comes strictly downwards from entrance, then turn.\n            # Aisle is the entrance column itself (225).\n            \n            # Waypoints:\n            # 1. Start at entrance (225, 50)\n            # 2. Move VERTICALLY down to target row (225, target_y)\n            # 3. Move HORIZONTALLY to target spot (420, target_y)\n            path_points_x = [entrance_x, entrance_x, target_x_val]\n            path_points_y = [entrance_y, target_y, target_y]\n            \n        else:\n            # All other cases involve moving horizontally to a different aisle first\n            if target_x_val < 800:     # Slot at 600 (Left Struct, Right Side)\n                aisle_x = 790          # Use Middle Road\n            elif target_x_val < 1050:  # Slot at 973 (Right Struct, Left Side)\n                aisle_x = 790          # Use Middle Road\n            else:                      # Slot at 1157 (Right Struct, Right Side)\n                aisle_x = 1250         # Use Right Road\n            \n            # Waypoints:\n            # 1. Start at entrance (225, 50)\n            # 2. Move VERTICALLY down (Forward) to cross-road level (225, 160)\n            #    (User requested \"go forward first then make the left turn\")\n            # 3. Move HORIZONTALLY to designated aisle (aisle_x, 160)\n            # 4. Move VERTICALLY down aisle (aisle_x, target_y)\n            # 5. Move HORIZONTALLY to target spot\n            cross_road_y = 160\n            path_points_x = [entrance_x, entrance_x, aisle_x, aisle_x, target_x_val]\n            path_points_y = [entrance_y, cross_road_y, cross_road_y, target_y, target_y]\n        \n        ax.plot(path_points_x, path_points_y, color='yellow', linestyle='-', \n               linewidth=4.0, zorder=1.5, alpha=0.9)\n\n    # Plot occupied spots with license plate images\n    for idx, row in occupied_spots.iterrows():\n        plate_number = row['plate_number']\n        if pd.notna(plate_number):\n            plate_img = load_plate_image(plate_number)\n            if plate_img is not None:\n                # Create annotation box with license plate image\n                ann = AnnotationBbox(plate_img, (row['x'], row['plot_y']), \n                                    frameon=False, zorder=2)\n                ax.add_artist(ann)\n        else:\n            # If no plate number, use red dot as fallback\n            ax.scatter(row['x'], row['plot_y'], c='red', alpha=0.7, s=80, \n                      zorder=1, edgecolors='black', linewidths=0.5)\n    \n    return []\n\n# Create animation frames - generate all frames\nprint(\"Generating animation frames...\")\nframes = []\nfor i in range(len(unique_timestamps)):\n    animate_frame(i)\n    fig.canvas.draw()\n    \n    # Save figure to a BytesIO buffer as PNG\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                facecolor='white', transparent=False)\n    buf.seek(0)\n    \n    # Read the PNG image and convert to numpy array\n    frame_img = Image.open(buf)\n    frame_array = np.array(frame_img)\n    \n    # Convert RGBA to RGB if needed (remove alpha channel)\n    if frame_array.shape[2] == 4:\n        frame_array = frame_array[:, :, :3]\n    \n    frames.append(frame_array)\n    buf.close()\n    \n    if (i + 1) % 10 == 0:\n        print(f\"  Generated {i + 1}/{len(unique_timestamps)} frames...\")\n\nprint(f\"\\nPreparing frames for 2-second display per minute...\")\n# Convert numpy arrays to PIL Images for better GIF control\n# Frames are already in RGB format from earlier conversion\npil_frames = [Image.fromarray(frame_array, 'RGB') for frame_array in frames]\n\nprint(f\"  Total frames: {len(pil_frames)}\")\nprint(f\"  Duration per frame: 2 seconds (2000 milliseconds)\")\n\n# Save as GIF using PIL's save method\n# duration is in milliseconds, so 2000ms = 2 seconds per frame\nprint(f\"\\nSaving animation as 'parking_animation.gif'...\")\npil_frames[0].save(\n    'parking_animation.gif',\n    save_all=True,\n    append_images=pil_frames[1:],\n    duration=2000,  # 2000 milliseconds = 2 seconds per frame\n    loop=0  # Loop indefinitely\n)\n\nprint(\"Animation saved successfully as 'parking_animation.gif'!\")\nplt.close()\n"}],"removed":[],"experiment_id":"EXP00004"}}]